<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>MyBlog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">秋</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li><li class="menu-item"><a href="/about/" target="_self">ABOUT</a></li></ul></div></nav><main class="prince-container"><div class="articles"><article class="post-block"><h2 class="post-title"><a href="/2022/05/06/LeetCode-Daily-Question-22/" class="post-link">LeetCode Daily Question 22</a></h2><div class="post-info">May 6th 2022</div><div class="post-entry"><h2 id="5-月-6-日-每日一题"><a href="#5-月-6-日-每日一题" class="headerlink" title="5 月 6 日 每日一题"></a>5 月 6 日 每日一题</h2><hr>
<h3 id="题目：169-Majority-Element"><a href="#题目：169-Majority-Element" class="headerlink" title="题目：169. Majority Element"></a>题目：169. Majority Element</h3><p>Given an array nums of size n, return the majority element.</p>
<p>The majority element is the element that appears more than ⌊n &#x2F; 2⌋ times. You may assume that the majority element always exists in the array.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题使用 Boyer–Moore majority vote algorithm，因为条件是必然存在 majority，本质可以理解为为每一个元素寻找一个不同的元素进行配对，应该存在 n&#x2F;2 个 pair，但 majority 一定出现多于 n&#x2F;2 次，所以最终剩余的无法配对的元素就是 majority。<img src="https://i.imgur.com/kv3Gl4Q.png" alt="截屏2022-05-06 下午11.44.32"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> majority = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= <span class="number">1</span>)</span><br><span class="line">                count += (num == majority) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/06/LeetCode-Daily-Question-22/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/06/LeetCode-Daily-Question-21/" class="post-link">LeetCode Daily Question 21</a></h2><div class="post-info">May 6th 2022</div><div class="post-entry"><h2 id="5-月-5-日-每日一题"><a href="#5-月-5-日-每日一题" class="headerlink" title="5 月 5 日 每日一题"></a>5 月 5 日 每日一题</h2><hr>
<h3 id="题目：11-Container-With-Most-Water"><a href="#题目：11-Container-With-Most-Water" class="headerlink" title="题目：11. Container With Most Water"></a>题目：11. Container With Most Water</h3><p>You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).</p>
<p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p>
<p>Return the maximum amount of water a container can store.</p>
<p>Notice that you may not slant the container.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题是关于双指针和贪心的题目，Greedy 的逻辑为：从可能最大的宽度起始，如果左边小，则 left++，如果右边小则 right–。因为水面高度永远取最小，所以如果移动大的一边，体积必然下降。如果 greedy 后得出的体积比当前的 maxArea 大，则修改当前 maxArea。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(height.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(left != right)&#123;</span><br><span class="line">            maxArea = <span class="built_in">max</span>(<span class="built_in">min</span>(height[left], height[right]) * (right - left), maxArea);</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/06/LeetCode-Daily-Question-21/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Greedy/" rel="tag">Greedy</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/02/%E5%86%99%E5%9C%A822WN%E7%9A%84%E6%9C%80%E5%90%8E/" class="post-link">写在22WN结束之后</a></h2><div class="post-info">May 2nd 2022</div><div class="post-entry"><p><img src="https://i.imgur.com/v7lcEWF.jpg" alt="16521651549140_.pic_hd"></p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>今天收到了 370 的 letter grade，有惊无险，算是圆满结束我的 22Winter Term。本篇文章旨在分析本学期几门课的学习效果。</p>
<h3 id="EECS-281"><a href="#EECS-281" class="headerlink" title="EECS 281"></a>EECS 281</h3><p>本学期最重量级的一门专业课，workload 60%出头，在完成四个 project 之外，还需要每周完成 lab 的 quiz，coding assignment，和 written problem。这门课最奇怪的还是抽题制考试，每个人考题难度差距很离谱，例如我觉得极难的 midterm 选择题平均分 45 分，但我觉得相对简单很多的 final 选择题平均分却是 35 分。感谢这门课的 Final，把我抬上了 A+。</p>
<p>学习这门课只是停留在 lecture 是肯定不够的，搭配 IA 的 Leetcode List 可以帮助掌握知识点，有时间的话强烈建议读一遍 notes，notes 的内容要比 slides 更细节，也涉及了更多知识点。</p>
<h3 id="EECS-370"><a href="#EECS-370" class="headerlink" title="EECS 370"></a>EECS 370</h3><p>本学期第二重量级的专业课，computer organization。内容偏重概念，project 是实现 Lc2k 的 assembler， simulator， linker 等一系列东西，以及写几个汇编软件。考试细心非常重要，我两次考得都一般，但 project 和 hw 拉满，所以拿 A 飘过了。</p>
<h3 id="STATS-250"><a href="#STATS-250" class="headerlink" title="STATS 250"></a>STATS 250</h3><p>巨水的统计课，讲了几个分布，如何做 Hypothesis Test &amp; Confidence Interval， 学了一些基础的 R， A+结束。</p>
<h3 id="EARTH-114，-LING-137，-ELI-210-and-ELI-131"><a href="#EARTH-114，-LING-137，-ELI-210-and-ELI-131" class="headerlink" title="EARTH 114， LING 137， ELI 210 and ELI 131"></a>EARTH 114， LING 137， ELI 210 and ELI 131</h3><p>前三门没有什么可说的，三门大水课，拿 A 了事。后两门 ELI 因为太忙，没有花多少时间，所以效果很差。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>对于像我一样第一次学数据结构的学生，不建议在一个学期同时学 370 和 281，我个人感觉 281 没有学扎实，计划暑假继续刷题，夯实基础。</p>
<p>虽然没有上过 STATS 412，考虑到 412 不用做无聊的 lab，我觉得会是比 250 更好的选择。</p>
</div><div class="post-meta"><a href="/2022/05/02/%E5%86%99%E5%9C%A822WN%E7%9A%84%E6%9C%80%E5%90%8E/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Summary/" rel="tag">Summary</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/04/13/%E5%86%99%E5%9C%A822WN%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAproject%E5%AE%8C%E7%BB%93%E4%B9%8B%E5%90%8E/" class="post-link">写在22WN最后一个project完结之后</a></h2><div class="post-info">Apr 13th 2022</div><div class="post-entry"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本周终于做完了 370，281 两门课的 Project4，虽然并没有如释重负的感觉（因为后面就是 Final），但还是有点小开心。这篇博文就总结一下这次的两个 p4。</p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>模拟一个简单的 Cache 运行，并且和 p1 写的 simulator 链接。需要考虑两种大情况，hit 和 miss，并且在 miss 时分类讨论是否有 empty block，难点应该是地址的转换。</p>
<h4 id="Debug-教训"><a href="#Debug-教训" class="headerlink" title="Debug 教训"></a>Debug 教训</h4><p>我写了一个比较离谱的 bug，if else 中都有 return，然后在 if else 结束之后写了一段对 LRU 的操作，如图：<br><img src="/images/370bug.png"><br>导致对 LRU 的操作没有执行。</p>
<h3 id="Pokemon"><a href="#Pokemon" class="headerlink" title="Pokemon"></a>Pokemon</h3><p>大概设定是你是一名宝可梦训练家，要收集齐所有宝可梦。从一些设定上看得出这个 Project 的作者应该是个资深的宝可梦的玩家，比如，二周目可以使用飞行（随意连接地图上的两个点），一周目如果要下海，必须先捕捉一只岸边的宝可梦获得冲浪技能。</p>
<p>PartA 本质上是写一个有限制的 MST，在搜寻目标点周围相邻点标记距离时增加一个 coast 和 sea 的判断（至少有一方在 coast 或两点都在 land），如果不符合则不标记两点之间的 d。MST 的本质是逐步选择和 SubGraph 最近的点并且逐步扩大 SubGraph，直到访问所有点。</p>
<p>PartB&amp;C 关于 TSP（traveling salesperson problem），即找到一条最优的路径访问所有点后并回到起始点构成一个环（Hamiltonian cycle）。</p>
<p>PartB 需要完成一个 FastTSP（TSP Heuristics） ，即更快的找到一条相对接近 Optimal TSP 的路径。我使用了 Arbitrary Insertion 的方法。</p>
<ol>
<li>随机选择第一个点 i</li>
<li>找到离 i 最近的第二个点 j，将路径设为 i -&gt; j -&gt; i。</li>
<li>对所有剩余的点进行循环，每次循环找到一个点加入当前的环（cost 最小），即遍历所有的 j 和 j-1 计算 (j -&gt; candidate -&gt; j-1) - (j -&gt; j-1) cost 最小时即为最优点。<br>*具体可见 281NotesC22Page37</li>
</ol>
<p>PartC 需要找到最优的 TSP，并尽可能优化算法，代码核心为 GenPerm（遍历所有可能的排列），为了尽可能增加效率，需要应用 Branch and Bound 的算法。那此时我们就需要考虑，如何得到算法需要的 upperBound 和 lowerBound？显然，upperBound 就是 PartB 的结果，lowerBound 的估计方法则是先找到两条 arm 一条从剩余点连接到 current path 的起始点，一条从剩余点连接到 current 的结尾点，并对剩余点计算 MST（minimum）。将 arm，current cost， MST 相加，结果极为 Lower Bound（在本问题可以视为最低 cost）。如下图所示：<br><img src="/images/281TSP.jpg"></p>
<h4 id="Debug-教训-1"><a href="#Debug-教训-1" class="headerlink" title="Debug 教训"></a>Debug 教训</h4><p><img src="/images/281bug.jpg"><br>我起初并没有用 tempDis 保存 distance，而是直接在 +&#x3D; 时调用 distancs[][]，但此时因为 swap，OPTpath[i]中的数据已经改变，+-的数据错误。</p>
</div><div class="post-meta"><a href="/2022/04/13/%E5%86%99%E5%9C%A822WN%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAproject%E5%AE%8C%E7%BB%93%E4%B9%8B%E5%90%8E/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Summary/" rel="tag">Summary</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/04/08/LeetCode-Daily-Question-20/" class="post-link">LeetCode Daily Question 20</a></h2><div class="post-info">Apr 8th 2022</div><div class="post-entry"><h2 id="4-月-8-日-每日一题"><a href="#4-月-8-日-每日一题" class="headerlink" title="4 月 8 日 每日一题"></a>4 月 8 日 每日一题</h2><hr>
<h3 id="题目：1245-Tree-Diameter"><a href="#题目：1245-Tree-Diameter" class="headerlink" title="题目：1245. Tree Diameter"></a>题目：1245. Tree Diameter</h3><p>The diameter of a tree is the maximum number of edges on any path connecting two nodes of the tree. For example, here are three sample trees and their diameters. In each case, the longest path is bolded and shown in purple. Note that there may be more than one longest path.</p>
<p>Implement the diameter() function, which computes the diameter of a binary tree represented by a pointer to an object of the BinaryTreeNode class. Assume that nullptr represents an empty tree or a missing child. You may write helper functions.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本道题是关于 tree 的递归题目。首先对问题进行分解，寻找问题和子问题的关系。<br>我们需要获得当前最大的 Diameter，它可能来自当前节点，左节点或右节点。<br>即 tempDia &#x3D; max (leftDia, rightDia, tempDia)。而 Dia 等于 leftHeight + rightHeight + 1。<br>因此，我们需要先计算 height，height 等于 1 + max(leftHeight, rightHeight)。<br>为了将时间复杂度简化到 On，建立 struct 同时储存 Hight 和当前 Diameter，在一个递归函数中可以同时完成上面提到的两个问题。<br>临界条件为 nullpointer，返回{1,1}.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> min(a,b)            (((a) &lt; (b)) ? (a) : (b))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> max(a,b)            (((a) &gt; (b)) ? (a) : (b))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTreeNode</span> &#123;</span><br><span class="line">  BinaryTreeNode* left;</span><br><span class="line">  BinaryTreeNode* right;</span><br><span class="line">  <span class="type">int</span> value;</span><br><span class="line">  <span class="built_in">BinaryTreeNode</span>(<span class="type">int</span> n) : left&#123;<span class="literal">nullptr</span>&#125;, right&#123;<span class="literal">nullptr</span>&#125;, value&#123;n&#125; &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">NodeInfo</span>&#123;</span><br><span class="line">    <span class="type">int</span> height;</span><br><span class="line">    <span class="type">int</span> diameter;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">NodeInfo <span class="title">helper</span><span class="params">(<span class="type">const</span> BinaryTreeNode* tree)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree)&#123;</span><br><span class="line">        <span class="keyword">return</span> NodeInfo&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    NodeInfo left = <span class="built_in">helper</span>(tree-&gt;left);</span><br><span class="line">    NodeInfo right = <span class="built_in">helper</span>(tree-&gt;right);</span><br><span class="line">    <span class="type">int</span> childrenDia = <span class="built_in">max</span>(left.diameter, right.diameter);</span><br><span class="line">    <span class="type">int</span> selfDia = <span class="number">1</span> + left.height + right.height;</span><br><span class="line">    <span class="type">int</span> tempDia = <span class="built_in">max</span>(childrenDia, selfDia);</span><br><span class="line">    <span class="keyword">return</span> NodeInfo&#123; <span class="number">1</span> + <span class="built_in">max</span>(left.height , right.height), tempDia&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">diameter</span><span class="params">(<span class="type">const</span> BinaryTreeNode* tree)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(tree).diameter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/04/08/LeetCode-Daily-Question-20/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Tree/" rel="tag">Tree</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/04/08/LeetCode-Daily-Question-19/" class="post-link">LeetCode Daily Question 19</a></h2><div class="post-info">Apr 8th 2022</div><div class="post-entry"><h2 id="4-月-8-日-每日一题"><a href="#4-月-8-日-每日一题" class="headerlink" title="4 月 8 日 每日一题"></a>4 月 8 日 每日一题</h2><hr>
<h3 id="题目：130-Surrounded-Regions"><a href="#题目：130-Surrounded-Regions" class="headerlink" title="题目：130. Surrounded Regions"></a>题目：130. Surrounded Regions</h3><p>Given an m x n matrix board containing ‘X’ and ‘O’, capture all regions that are 4-directionally surrounded by ‘X’.</p>
<p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">Output: [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]</span><br><span class="line">Explanation: Surrounded regions should not be on the border, which means that any &#x27;O&#x27; on the border of the board are not flipped to &#x27;X&#x27;. Any &#x27;O&#x27; that is not on the border and it is not connected to an &#x27;O&#x27; on the border will be flipped to &#x27;X&#x27;. Two cells are connected if they are adjacent cells connected horizontally or vertically.</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>今天这道题和昨天的差不多，在昨天的代码上做一些改动即可。即为进入 BFS 增加一个限制条件（必须在边界），在 BFS 中做好标记。最后循环一遍，将做好标记的点改为 O，其余改为 X。<br>等下再做一道放上来，这个和昨天的太像了…</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">dequePoint</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">uint32_t</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="type">uint32_t</span> y = <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">uint32_t</span> x, <span class="type">uint32_t</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> board[y][x] == <span class="string">&#x27;O&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">valid1</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">uint32_t</span> x, <span class="type">uint32_t</span> y)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; board[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; board.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">bfsHelper</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">char</span>&gt;&gt;&amp; board, <span class="type">uint32_t</span> x, <span class="type">uint32_t</span> y)</span></span>&#123;</span><br><span class="line">        queue&lt;dequePoint&gt; queue;</span><br><span class="line">        queue.<span class="built_in">push</span>(dequePoint&#123;x,y&#125;);</span><br><span class="line">        board[y][x] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            x = queue.<span class="built_in">front</span>().x;</span><br><span class="line">            y = queue.<span class="built_in">front</span>().y;</span><br><span class="line">            queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(board, x - <span class="number">1</span>, y))&#123;</span><br><span class="line">                queue.<span class="built_in">push</span>(dequePoint&#123;x - <span class="number">1</span>,y&#125;);</span><br><span class="line">                board[y][x - <span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(board, x + <span class="number">1</span>, y))&#123;</span><br><span class="line">                queue.<span class="built_in">push</span>(dequePoint&#123;x + <span class="number">1</span>,y&#125;);</span><br><span class="line">                board[y][x + <span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(board, x, y - <span class="number">1</span>))&#123;</span><br><span class="line">                queue.<span class="built_in">push</span>(dequePoint&#123;x,y - <span class="number">1</span>&#125;);</span><br><span class="line">                board[y - <span class="number">1</span>][x] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">valid</span>(board, x, y + <span class="number">1</span>))&#123;</span><br><span class="line">                queue.<span class="built_in">push</span>(dequePoint&#123;x,y + <span class="number">1</span>&#125;);</span><br><span class="line">                board[y + <span class="number">1</span>][x] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint32_t</span> y = <span class="number">0</span>; y &lt; board.<span class="built_in">size</span>(); y++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">uint32_t</span> x = <span class="number">0</span>; x &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); x++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!<span class="built_in">valid1</span>(board, x - <span class="number">1</span>, y) || !<span class="built_in">valid1</span>(board, x + <span class="number">1</span>, y) ||</span><br><span class="line">                   !<span class="built_in">valid1</span>(board, x, y - <span class="number">1</span>) || !<span class="built_in">valid1</span>(board, x, y + <span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[y][x] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                        <span class="built_in">bfsHelper</span>(board, x, y);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint32_t</span> y = <span class="number">0</span>; y &lt; board.<span class="built_in">size</span>(); y++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">uint32_t</span> x = <span class="number">0</span>; x &lt; board[<span class="number">0</span>].<span class="built_in">size</span>(); x++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(board[y][x] == <span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">                    board[y][x] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    board[y][x] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/04/08/LeetCode-Daily-Question-19/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/BFS/" rel="tag">BFS</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/04/07/LeetCode-Daily-Question-18/" class="post-link">LeetCode Daily Question 18</a></h2><div class="post-info">Apr 7th 2022</div><div class="post-entry"><h2 id="4-月-7-日-每日一题"><a href="#4-月-7-日-每日一题" class="headerlink" title="4 月 7 日 每日一题"></a>4 月 7 日 每日一题</h2><hr>
<h3 id="题目：Number-of-Islands"><a href="#题目：Number-of-Islands" class="headerlink" title="题目：Number of Islands:"></a>题目：Number of Islands:</h3><p>In this problem, you will be implementing the number of islands() function, as shown below:<br>int number_of_islands(std::vector&lt;std::vector<char>&gt; &amp;grid);<br>This function takes in a 2-D grid map filled with land (represented using the character ’o’) and water (represented using the character ’.’) and returns the number of islands that exist in the map. An island is formed by connecting adjacent land characters either horizontally or vertically. In other words, if two land characters are adjacent to each other horizontally or vertically, then they are a part of the same island.</char></p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>今天这道题并不是 leetcode，做法和昨天的 547 类似，在主函数遍历地图所有点，遇到新的地图时调用 BFS。本道题 BFS 使用了 queue 的写法。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">dequePoint</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="type">uint32_t</span> y = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">valid</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">uint32_t</span> x, <span class="type">uint32_t</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x &gt;= <span class="number">0</span> &amp;&amp; x &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>() &amp;&amp; y &gt;= <span class="number">0</span> &amp;&amp; y &lt; grid.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> grid[y][x] == <span class="string">&#x27;o&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfsHelper</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid, <span class="type">uint32_t</span> x, <span class="type">uint32_t</span> y)</span></span>&#123;</span><br><span class="line">    queue&lt;dequePoint&gt; queue;</span><br><span class="line">    queue.<span class="built_in">push</span>(dequePoint&#123;x,y&#125;);</span><br><span class="line">    grid[y][x] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span>(!queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        x = queue.<span class="built_in">front</span>().x;</span><br><span class="line">        y = queue.<span class="built_in">front</span>().y;</span><br><span class="line">        queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">valid</span>(grid, x - <span class="number">1</span>, y))&#123;</span><br><span class="line">            queue.<span class="built_in">push</span>(dequePoint&#123;x - <span class="number">1</span>,y&#125;);</span><br><span class="line">            grid[y][x - <span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">valid</span>(grid, x + <span class="number">1</span>, y))&#123;</span><br><span class="line">            queue.<span class="built_in">push</span>(dequePoint&#123;x + <span class="number">1</span>,y&#125;);</span><br><span class="line">            grid[y][x + <span class="number">1</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">valid</span>(grid, x, y - <span class="number">1</span>))&#123;</span><br><span class="line">            queue.<span class="built_in">push</span>(dequePoint&#123;x,y - <span class="number">1</span>&#125;);</span><br><span class="line">            grid[y - <span class="number">1</span>][x] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">valid</span>(grid, x, y + <span class="number">1</span>))&#123;</span><br><span class="line">            queue.<span class="built_in">push</span>(dequePoint&#123;x,y + <span class="number">1</span>&#125;);</span><br><span class="line">            grid[y + <span class="number">1</span>][x] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">number_of_islands</span><span class="params">(std::vector&lt;std::vector&lt;<span class="type">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> islandNum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">uint32_t</span> i = <span class="number">0</span>; i &lt; grid.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">uint32_t</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(grid[i][j] == <span class="string">&#x27;o&#x27;</span>)&#123;</span><br><span class="line">                islandNum++;</span><br><span class="line">                <span class="built_in">bfsHelper</span>(grid, j, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(islandNum);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/04/07/LeetCode-Daily-Question-18/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/BFS/" rel="tag">BFS</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/04/06/LeetCode-Daily-Question-17/" class="post-link">LeetCode Daily Question 17</a></h2><div class="post-info">Apr 6th 2022</div><div class="post-entry"><h2 id="4-月-6-日-每日一题"><a href="#4-月-6-日-每日一题" class="headerlink" title="4 月 6 日 每日一题"></a>4 月 6 日 每日一题</h2><hr>
<h3 id="题目：547-Number-of-Provinces"><a href="#题目：547-Number-of-Provinces" class="headerlink" title="题目：547. Number of Provinces"></a>题目：547. Number of Provinces</h3><p>There are n cities. Some of them are connected, while some are not. If city a is connected directly with city b, and city b is connected directly with city c, then city a is connected indirectly with city c.</p>
<p>A province is a group of directly or indirectly connected cities and no other cities outside of the group.</p>
<p>You are given an n x n matrix isConnected where isConnected[i][j] &#x3D; 1 if the ith city and the jth city are directly connected, and isConnected[i][j] &#x3D; 0 otherwise.</p>
<p>Return the total number of provinces.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input: isConnected = [[1,1,0],[1,1,0],[0,0,1]]</span><br><span class="line">Output: 2</span><br><span class="line"></span><br><span class="line">Input: isConnected = [[1,0,0],[0,1,0],[0,0,1]]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>遍历所有 vertex，如果当前 vertex 为 unvisited，num++，并且使用 dfs 遍历该所有和该节点在一个 province 的节点，并把他们标记为 visited。dfs 结束后回到原函数继续对剩余 vertex 进行遍历。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfsHelper</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected, vector&lt;<span class="type">bool</span>&gt;&amp; visited, <span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">        visited[i] =<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; isConnected.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isConnected[i][j] &amp;&amp; !visited[j])&#123;</span><br><span class="line">                <span class="built_in">dfsHelper</span>(isConnected, visited, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">visited</span><span class="params">(isConnected.size(),<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> circleNum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; visited.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])&#123;</span><br><span class="line">                circleNum++;</span><br><span class="line">                <span class="built_in">dfsHelper</span>(isConnected, visited, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> circleNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/04/06/LeetCode-Daily-Question-17/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/DFS/" rel="tag">DFS</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/03/30/LeetCode-Daily-Question-16/" class="post-link">LeetCode Daily Question 16</a></h2><div class="post-info">Mar 30th 2022</div><div class="post-entry"><h2 id="3-月-31-日-每日一题"><a href="#3-月-31-日-每日一题" class="headerlink" title="3 月 31 日 每日一题"></a>3 月 31 日 每日一题</h2><hr>
<h3 id="题目：560-Subarray-Sum-Equals-K"><a href="#题目：560-Subarray-Sum-Equals-K" class="headerlink" title="题目：560. Subarray Sum Equals K"></a>题目：560. Subarray Sum Equals K</h3><p>Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,1,1], k = 2</span><br><span class="line">Output: 2</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: nums = [1,2,3], k = 3</span><br><span class="line">Output: 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Constraints:</span><br><span class="line"></span><br><span class="line">1 &lt;= nums.length &lt;= 2 * 104</span><br><span class="line">-1000 &lt;= nums[i] &lt;= 1000</span><br><span class="line">-107 &lt;= k &lt;= 107</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>因为 constrain 提到 nums 中可能有负数，所以本题无法使用 sliding window（无法保证区间缩小会使 sum 减小）。正确做法是使用一个命名为 prefixNum 的 hashmap 存储每一个 prefixSum 出现的次数。并使用一个 for 循环从 0 - 0， 0 - 1， 0 - 2 逐渐扩大 subarray size，如果当前的 sum - k 的数字可以在 hashmap 中找到，说明当前范围，减去 prefix 的范围可以得到 k，那么此时 res + prefixSum 的 second value。<br>本题需要考虑三个点，第一个 edge case 是 prefixSum 为 0 例如 1 + 1 为 2， k 为 2，并不需要减去 prefix，所以在开始遍历之前要给 prefixSum &#x3D; 0 赋 1.<br>第二，不能先记录 prefixSum 再开始遍历，这样可能会出现 window 比当前区间大的情况。<br>第三，循环时应该先判断 judge 再记录 prefixSum，以避免 window 是当前区间本身。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; prefixSum;</span><br><span class="line">        prefixSum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">size_t</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="type">int</span> judge = sum - k;</span><br><span class="line">            <span class="keyword">auto</span> iter = prefixSum.<span class="built_in">find</span>(judge);</span><br><span class="line">            <span class="keyword">if</span>(iter != prefixSum.<span class="built_in">end</span>())&#123;</span><br><span class="line">                res += iter-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">            prefixSum[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>错误实例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; prefixSum;</span><br><span class="line">        prefixSum[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">size_t</span> size = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++)&#123;</span><br><span class="line">            <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">                sum += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> judge = sum - k;</span><br><span class="line">            <span class="keyword">auto</span> iter = prefixSum.<span class="built_in">find</span>(judge);</span><br><span class="line">            <span class="keyword">if</span>(iter != prefixSum.<span class="built_in">end</span>())&#123;</span><br><span class="line">                res += iter-&gt;second;</span><br><span class="line">            &#125;</span><br><span class="line">            prefixSum[sum]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/03/30/LeetCode-Daily-Question-16/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/hashMap/" rel="tag">hashMap</a>, <a class="tag-link" href="/tags/prefixSum/" rel="tag">prefixSum</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/03/28/Summary-of-Projects-for-281-370/" class="post-link">Summary of Projects for 281&amp;370</a></h2><div class="post-info">Mar 28th 2022</div><div class="post-entry"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>鸽了一周，今天开始恢复更新。就先总结过去一周所做的两个 Project，Pipelined Simulator &amp; SillyQL。</p>
<h3 id="Pipelined-Simulator"><a href="#Pipelined-Simulator" class="headerlink" title="Pipelined Simulator"></a>Pipelined Simulator</h3><p>370 的 p3，大概就是写一些代码模拟 pipeline 的运行过程，利用 Detect and Forward 处理 data Hazard，使用 branch-not-taken 解决 Control Hazard。因为暂时不会使用 c 语言的并行处理，所以利用两个 struct， State 和 newState 来模拟时钟上升沿 state 的瞬时更新。开写之前我其实没有完全理解这个方法，之后修改时又漏掉了 eq，给我造成了很大麻烦。 所以教训是要严格遵守 spec 的要求，例如 State 都作为左值，newState 都作为右值。整体而言 p3 难度不算大，我个人比较喜欢这种概念性比较强的 Project。</p>
<h3 id="SillyQL"><a href="#SillyQL" class="headerlink" title="SillyQL"></a>SillyQL</h3><p>模拟一个简陋版的 sql，spec 指定了几个功能，首先实现 create，print，insert，remove，delete，然后实现 generate（给一个 col 加 hash&#x2F;bst 以提高查找速度），join（两个 table 的交集）。写完 generate 之后要对 print 做一些优化（’&gt;’, ‘&lt;’时使用 bst 的 upper_bound， ‘&#x3D;’ 时使用 hash)。</p>
<p>这里并不需要对 delete 做什么优化，因为‘&#x3D;’时 remove_if 和使用 hash 查找从后往前 delte 时间复杂度都是 O(n)。delete 结束后需要 rehash&#x2F;rebst。此处我以为‘&#x3D;’时可以直接 erase bst 里的 key，这个操作导致了很严重的 bug，因为 bst 的 value 里存储的是每一个 key 对应的 row 的 index，如果某一行被 delete，之后所有 row 的 index 都会前移，所以会导致 bst 存储的 index 完全失效。</p>
<p>p3 算是目前为止我接触的比较大的 project，spec25 页，程序大概 900 行。因为比较缺乏大型 project 的经验，前后写了很久，debug 花了一天半，因此误了好几节 recording。好在程序结构问题，不用做额外的 speed &amp; memory 优化。所以，之后的大型 project 一定要早点开始。安排好时间，起码不要误课，而且一直做一件事效率有点低。。。</p>
<p>总之，相比这学期开始，代码能力也算有一些提升，但还有很长路要走啊…<br>结尾附图一张<br><img src="/images/5.jpg"></p>
</div><div class="post-meta"><a href="/2022/03/28/Summary-of-Projects-for-281-370/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Summary/" rel="tag">Summary</a></div></div></article></div><div class="paginator"><div class="prev-wrap col-md-6 col-xs-6"><i class="fa fa-angle-double-left"></i><a href="/" class="prev-page">Previous</a></div><div class="next-wrap col-md-6 col-xs-6"><a href="/page/3/" class="next-page">Next</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;秋&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>