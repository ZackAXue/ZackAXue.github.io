<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>MyBlog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">秋</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li><li class="menu-item"><a href="/about/" target="_self">ABOUT</a></li></ul></div></nav><main class="prince-container"><div class="articles"><article class="post-block"><h2 class="post-title"><a href="/2022/12/12/Nothern-Michigan/" class="post-link">Network Motif Analysis for Functional Brain Network Under Different Intelligence Tasks</a></h2><div class="post-info">Dec 12th 2022</div><div class="post-entry"><p><img src="/images/501_final_project/neuron.jpg"></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a><strong>Preface</strong></h1><p>This research guide consists of two parts. The text part covers the background of the project, introduction and motif-find algorithm analysis. The video part covers the pre-processing method for fMRI of brain regions, ROI selection and network modeling methods.</p>
<h1 id="Backgraound"><a href="#Backgraound" class="headerlink" title="Backgraound"></a><strong>Backgraound</strong></h1><p>In the study of human intelligence, researchers have long sought to understand the relationship between the functional organization of the brain and individual cognitive abilities. One approach to this problem is to use functional MRI to obtain the brain network in response to a particular stimulus, and then apply algorithms based on graph theory to analyze the structure and function of the network. In this project, two brain network modeling methods were implemented: regularized inverse covariance and Bayesian networks. Three motif-searching methods were also used to analyze changes in network motif over time: FANMOD, MAVisto, and GK. These algorithms were applied to data collected from participants performing twelve subtasks from an established intelligence test in order to uncover patterns and temporal information in the brain network. </p>
<h1 id="Why-I-Made-This"><a href="#Why-I-Made-This" class="headerlink" title="Why I Made This"></a><strong>Why I Made This</strong></h1><p>I am an undergraduate student majoring in Computer Science at the University of Michigan. I also have a minor in Complex Systems and Statistics. In the fall semester of 2022, I took the class CONMPLXSYS501 Introduction to complex systems. I was fascinated by many of the concepts in complex systems, especially the section on network analysis, especially for its application in neuroscience. Understanding how the human brain works may help us to explore the potential of artificial intelligence and to accomplish real artificial intelligence. Therefore, I chose the analysis of brain networks for my final project. </p>
<p>So, I decided to focus on the analysis of brain networks for my final project, but found the project to be more challenging than I had anticipated. In order to better understand the topic, I spent a considerable amount of time researching neuroscience concepts and learning about the processing of fMRI data and the pros and cons of different algorithms for network modeling. Despite facing limited personal computing resources and other challenges, I persevered and completed my project. This experience has given me a deeper appreciation for the rigors of scientific research and the thrill of exploring uncharted territory.</p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h1><p>A network motif is a small, recurring pattern that occurs within the structure of a network. These patterns are thought to play a key role in the functioning of the network by providing a basic building block for the organization and operation of the system. For example, in a biological network, a motif might represent a specific interaction between proteins that has a particular biological function. To do this in brain, researchers use functional magnetic resonance imaging (fMRI) data to construct brain networks, and then apply algorithms based on graph theory to search for network motifs. However, motif research on Brain Network focus more on Resting-State network or under single task.<br>Static data cannot help us understand the underlying logic of how the brain operates. To solve this problem, I modeled brain fMRI for subjects participating in each of the 12 intelligence tests, and perform motif finding algorithm to them. This can help to reveal underlying organizational principles in brain and to understand how these patterns may be related to cognitive processes and behavior.</p>
<h1 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a><strong>Approach</strong></h1><p>The project pipeline consists of the following three parts.</p>
<ol>
<li>pre-processing of FMRI timing data and selection of region of interest (ROI)</li>
<li>acquiring the voxel timing signal and obtaining the brain network by network modeling.</li>
<li>finding the feature nodes in the network using the motif finding algorithm.<br><img src="/images/501_final_project/pipeline.png"></li>
</ol>
<h2 id="fMRI-Pre-processing-amp-ROI-Selection"><a href="#fMRI-Pre-processing-amp-ROI-Selection" class="headerlink" title="fMRI Pre-processing &amp; ROI Selection"></a><strong>fMRI Pre-processing &amp; ROI Selection</strong></h2><iframe height="498" width="510" src="https://player.youku.com/embed/XNTkyNjc0NjI0OA==" frameborder="0" 'allowfullscreen'></iframe>

<h2 id="Network-modeling-amp-Motif-Finding"><a href="#Network-modeling-amp-Motif-Finding" class="headerlink" title="Network-modeling &amp; Motif Finding"></a><strong>Network-modeling &amp; Motif Finding</strong></h2><h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h1></div><div class="post-meta"><a href="/2022/12/12/Nothern-Michigan/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/written-research-tutorial/" rel="tag">written research tutorial</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/08/25/great-smoky-mountain/" class="post-link">Great Smoky Mountain</a></h2><div class="post-info">Aug 25th 2022</div><div class="post-entry"><p><img src="/images/great_smoky_mountain/pic1.jpg"><br><img src="/images/great_smoky_mountain/pic2.jpg"><br><img src="/images/great_smoky_mountain/pic3.jpg"><br><img src="/images/great_smoky_mountain/pic4.jpg"><br><img src="/images/great_smoky_mountain/pic5.jpg"></p>
</div><div class="post-meta"><a href="/2022/08/25/great-smoky-mountain/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Gallery/" rel="tag">Gallery</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/07/26/Chicago/" class="post-link">Chicago</a></h2><div class="post-info">Jul 26th 2022</div><div class="post-entry"><p><img src="/images/Chicago/pic1.jpg"><br><img src="/images/Chicago/pic2.jpg"><br><img src="/images/Chicago/pic3.jpg"><br><img src="/images/Chicago/pic4.jpg"><br><img src="/images/Chicago/pic5.jpg"><br><img src="/images/Chicago/pic6.jpg"><br><img src="/images/Chicago/pic7.jpg"><br><img src="/images/Chicago/pic8.jpg"><br><img src="/images/Chicago/pic9.jpg"><br><img src="/images/Chicago/pic10.jpg"></p>
</div><div class="post-meta"><a href="/2022/07/26/Chicago/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Gallery/" rel="tag">Gallery</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/07/21/LeetCode-Daily-Question-34/" class="post-link">LeetCode-Daily-Question-34</a></h2><div class="post-info">Jul 21st 2022</div><div class="post-entry"><h2 id="7-月-21-日-每日一题"><a href="#7-月-21-日-每日一题" class="headerlink" title="7 月 21 日 每日一题"></a>7 月 21 日 每日一题</h2><hr>
<h3 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h3><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p>
<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits = &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Using bsf (a queue) or a temp vector to store the intermediate status of the combinations.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;string&gt; phone = &#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        queue&lt;string&gt; bsf;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        bsf.<span class="built_in">push</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!bsf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            string s = bsf.<span class="built_in">front</span>();</span><br><span class="line">            bsf.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">length</span>() == digits.<span class="built_in">length</span>())</span><br><span class="line">                ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c: phone[digits[s.<span class="built_in">length</span>()] - <span class="string">&#x27;0&#x27;</span>])</span><br><span class="line">                    bsf.<span class="built_in">push</span>(s + c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/07/21/LeetCode-Daily-Question-34/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/bfs/" rel="tag">bfs</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/07/20/LeetCode-Daily-Question-33/" class="post-link">LeetCode-Daily-Question-33</a></h2><div class="post-info">Jul 20th 2022</div><div class="post-entry"><h2 id="7-月-20-日-每日一题"><a href="#7-月-20-日-每日一题" class="headerlink" title="7 月 20 日 每日一题"></a>7 月 20 日 每日一题</h2><hr>
<h3 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a>543. Diameter of Binary Tree</h3><p>Given the root of a binary tree, return the length of the diameter of the tree.</p>
<p>The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>
<p>The length of a path between two nodes is represented by the number of edges between them.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>It is similar to height of tree. Diameter &#x3D; Height of the left subtree + Height of the right subtree. Keep track of the maxDiameter during traversal by an extra parameter and get the height of the tree.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> diameter = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">diaHelper</span>(root, diameter);</span><br><span class="line">        <span class="keyword">return</span> diameter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diaHelper</span><span class="params">(TreeNode* node, <span class="type">int</span>&amp; diameter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">diaHelper</span>(node-&gt;left, diameter);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">diaHelper</span>(node-&gt;right, diameter);</span><br><span class="line">        diameter = <span class="built_in">max</span>(diameter, left + right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/07/20/LeetCode-Daily-Question-33/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/recursive/" rel="tag">recursive</a>, <a class="tag-link" href="/tags/tree/" rel="tag">tree</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/07/19/LeetCode-Daily-Question-32/" class="post-link">LeetCode Daily-Question 32</a></h2><div class="post-info">Jul 19th 2022</div><div class="post-entry"><h2 id="7-月-19-日-每日一题"><a href="#7-月-19-日-每日一题" class="headerlink" title="7 月 19 日 每日一题"></a>7 月 19 日 每日一题</h2><hr>
<h3 id="117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="117. Populating Next Right Pointers in Each Node II"></a>117. Populating Next Right Pointers in Each Node II</h3><p>Given a binary tree</p>
<p>struct Node {<br>int val;<br>Node *left;<br>Node *right;<br>Node *next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,null,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,7,#]</span><br><span class="line">Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#x27;#&#x27; signifying the end of each level.</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>The difference between 116 and 117 is that 117 is not a perfect binary tree, which means it cannot be simply solved by recursive.</p>
<p>The direct way is to use iterative BSF. Note that when reach to null, it’s time to move to the next level and add a nullptr to the end of the queue(for the next level end).</p>
<p>There is a O(1) space complexity way, which is a bit similar to double pointer. The detail is in comments of code. Note the when proceed the current level(currParent), the next has been proceed by last while loop.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Way 1:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        queue&lt;Node*&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            Node* curr = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!curr)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left)</span><br><span class="line">                q.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right)</span><br><span class="line">                q.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Way 2:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        Node *currParent = root;</span><br><span class="line">        Node *baseChild;</span><br><span class="line">        Node *currChild;</span><br><span class="line">        Node *nextChild;</span><br><span class="line">        <span class="keyword">while</span>(currParent)&#123;</span><br><span class="line">            <span class="comment">//reach to a parent with at least one child</span></span><br><span class="line">            <span class="keyword">while</span>(currParent-&gt;next &amp;&amp; !currParent-&gt;left &amp;&amp; !currParent-&gt;right)</span><br><span class="line">                currParent = currParent-&gt;next;</span><br><span class="line">            <span class="comment">//set baseChild and currChild to the first child of the next level</span></span><br><span class="line">            currChild = baseChild = currParent-&gt;left ? currParent-&gt;left : currParent-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(currChild)&#123;</span><br><span class="line">                <span class="comment">//if currChild is left child and have right sibling</span></span><br><span class="line">                <span class="keyword">if</span>(currParent-&gt;right &amp;&amp; currParent-&gt;right != currChild)&#123;</span><br><span class="line">                    nextChild = currParent-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//move to the adjacent parent</span></span><br><span class="line">                    currParent = currParent-&gt;next;</span><br><span class="line">                    <span class="keyword">while</span>(currParent &amp;&amp; !currParent-&gt;left &amp;&amp; !currParent-&gt;right)&#123;</span><br><span class="line">                        currParent = currParent-&gt;next;</span><br><span class="line">                        <span class="comment">//now currParent has pointed to the next Parent</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//if not reach to the end</span></span><br><span class="line">                    <span class="keyword">if</span>(currParent)&#123;</span><br><span class="line">                        nextChild = currParent-&gt;left ? currParent-&gt;left : currParent-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//if reach to the end</span></span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//if reach to the end of this level</span></span><br><span class="line">                        nextChild = <span class="literal">nullptr</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                currChild-&gt;next = nextChild;</span><br><span class="line">                currChild = nextChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//move to the next level</span></span><br><span class="line">            currParent = baseChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/07/19/LeetCode-Daily-Question-32/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/bfs/" rel="tag">bfs</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/tree/" rel="tag">tree</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/07/18/LeetCode-Daily-Question-31/" class="post-link">LeetCode Daily Question 31</a></h2><div class="post-info">Jul 18th 2022</div><div class="post-entry"><h2 id="7-月-18-日-每日一题"><a href="#7-月-18-日-每日一题" class="headerlink" title="7 月 18 日 每日一题"></a>7 月 18 日 每日一题</h2><hr>
<p>时隔两个月的更新，之后会恢复每日一题，频率定为每周六题</p>
<h3 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a>116. Populating Next Right Pointers in Each Node</h3><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<p>struct Node {<br>int val;<br>Node *left;<br>Node *right;<br>Node *next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#x27;#&#x27; signifying the end of each level.</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>For recursive, firstly, point root-&gt;left-&gt;next to root-&gt;right-&gt;next. Then use root’s next arrow to find right children’s buddy in the neighboring tree. Take care of current level’s children’s next problem and then move down to children subtree.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val) : <span class="built_in">val</span>(_val), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val, Node* _left, Node* _right, Node* _next)</span><br><span class="line">        : <span class="built_in">val</span>(_val), <span class="built_in">left</span>(_left), <span class="built_in">right</span>(_right), <span class="built_in">next</span>(_next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next)&#123;</span><br><span class="line">                root-&gt;right-&gt;next = root-&gt;next-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">connect</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">connect</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/07/18/LeetCode-Daily-Question-31/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/tree/" rel="tag">tree</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/06/24/Meadow-Picnic-6-23/" class="post-link">Meadow Picnic 6.23</a></h2><div class="post-info">Jun 24th 2022</div><div class="post-entry"><h2 id="Meadow-Picnic-2"><a href="#Meadow-Picnic-2" class="headerlink" title="Meadow Picnic_2"></a>Meadow Picnic_2</h2><hr>
<p>久违的更新，新开辟的一个 tag，记录现在和以后的摄影作品（可能还算不上作品<br><img src="/images/6.23/pic1.jpg"></p>
<p><img src="/images/6.23/pic2.jpg"></p>
<p><img src="/images/6.23/pic3.jpg"></p>
<p><img src="/images/6.23/pic4.jpg"></p>
<p><img src="/images/6.23/pic5.jpg"></p>
<p><img src="/images/6.23/pic6.jpg"></p>
<p><img src="/images/6.23/pic7.jpg"></p>
<p><img src="/images/6.23/pic8.jpg"></p>
<p><img src="/images/6.23/pic9.jpg"></p>
</div><div class="post-meta"><a href="/2022/06/24/Meadow-Picnic-6-23/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Gallery/" rel="tag">Gallery</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/17/LeetCode-Daily-Question-30/" class="post-link">LeetCode Daily Question 30</a></h2><div class="post-info">May 17th 2022</div><div class="post-entry"><h2 id="5-月-14-日-每日一题"><a href="#5-月-14-日-每日一题" class="headerlink" title="5 月 14 日 每日一题"></a>5 月 14 日 每日一题</h2><hr>
<h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h3><p>One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as ‘#’.</p>
<p>For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where ‘#’ represents a null node.</p>
<p>Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree.</p>
<p>It is guaranteed that each comma-separated value in the string must be either an integer or a character ‘#’ representing null pointer.</p>
<p>You may assume that the input format is always valid.</p>
<p>For example, it could never contain two consecutive commas, such as “1,,3”.<br>Note: You are not allowed to reconstruct the tree.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: preorder = &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: preorder = &quot;1,#&quot;</span><br><span class="line">Output: false</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: preorder = &quot;9,#,#,1&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题有两种写法，我用了最笨的一种，每遇到两个#，将这两个 hash 和对应的 leaf node 删掉，然后添加一个#，要注意的是需要使用 while 循环，因为可能会在添加#之后形成新的满足 pop 要求的组合。要注意的是不能直接用 index 访问，因为可能会出现两位数字（92）。<br>另一种写法是聪明很多，因为 external node 数量必然比 internal 多 1，每遇到一个 val，counter++，遇到#，counter–，如果读完所有的 node 时，count 为-1，则有效（如果未读完所有 node，count 就为 1，意味着此时已经无法插入 node，则此 tree 无效）。<br><img src="/2022/05/17/LeetCode-Daily-Question-30/%E6%88%AA%E5%B1%8F2022-05-18%20%E4%B8%8B%E5%8D%888.44.49_31e0yfghz.png" alt="截屏2022-05-18 下午8.44.49"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSerialization</span><span class="params">(string preorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if it&#x27;s #</span></span><br><span class="line">        <span class="keyword">if</span>(preorder[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; preorder.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(preorder[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; preorder.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        preorder += <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        <span class="function">stringstream <span class="title">str</span><span class="params">(preorder)</span></span>;</span><br><span class="line">        string ele;</span><br><span class="line">        <span class="built_in">getline</span>(str, ele, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        vector&lt;string&gt; stack;</span><br><span class="line">        stack.<span class="built_in">push_back</span>(ele);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(str, ele, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">            stack.<span class="built_in">push_back</span>(ele);</span><br><span class="line">            <span class="keyword">if</span>(stack.<span class="built_in">back</span>() == <span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(stack.<span class="built_in">size</span>() &gt; <span class="number">2</span> &amp;&amp; stack.<span class="built_in">back</span>() == <span class="string">&quot;#&quot;</span> &amp;&amp; stack[stack.<span class="built_in">size</span>() - <span class="number">2</span>] == <span class="string">&quot;#&quot;</span> &amp;&amp; stack[stack.<span class="built_in">size</span>() - <span class="number">3</span>] != <span class="string">&quot;#&quot;</span> )&#123;</span><br><span class="line">                    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">                    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">                    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">                    stack.<span class="built_in">push_back</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; stack.<span class="built_in">back</span>() == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidSerialization</span><span class="params">(string p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream ss&#123;p&#125;;</span><br><span class="line">	<span class="type">int</span> c&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>( ; c!=<span class="number">-1</span> <span class="keyword">and</span> !ss.<span class="built_in">eof</span>(); <span class="built_in">getline</span>(ss, p, <span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        p[<span class="number">0</span>]==<span class="string">&#x27;#&#x27;</span> ? --c : ++c；</span><br><span class="line">	<span class="keyword">return</span> c==<span class="number">-1</span> <span class="keyword">and</span> ss.<span class="built_in">eof</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/17/LeetCode-Daily-Question-30/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/tree/" rel="tag">tree</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/14/LeetCode-Daily-Question-29/" class="post-link">LeetCode Daily Question 29</a></h2><div class="post-info">May 14th 2022</div><div class="post-entry"><h2 id="5-月-14-日-每日一题"><a href="#5-月-14-日-每日一题" class="headerlink" title="5 月 14 日 每日一题"></a>5 月 14 日 每日一题</h2><hr>
<h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h3><p>Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题使用递归的写法，首先思考递归公式：</p>
<ol>
<li>将 preoder 的局部第一位设为 root（left 区域的第一个 preorder 或 right 区域的第一个 preoder，因此需要一个 prestart 参数）。</li>
<li>找到该 preorder element 在 inorder 中的 index。</li>
<li>针对该 preorder element 的 left 区域进入子问题（因此需要 instart 和 inEnd 参数）。</li>
<li>针对该 preoder element 的 right 区域进入子问题。</li>
</ol>
<p>第二步思考临界条件：<br>prestart &gt;&#x3D; preorder.size() || instart &gt; inend 时返回 nullptr（无 node）</p>
<p>第三步实现代码。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildHelper</span>(preorder, inorder, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">int</span>(inorder.<span class="built_in">size</span>() - <span class="number">1</span>), index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preStart, <span class="type">int</span> inStart, <span class="type">int</span> inEnd, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt;= preorder.<span class="built_in">size</span>() || inStart &gt; inEnd)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode&#123;preorder[preStart], <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="type">int</span> curIndex = index[preorder[preStart]];</span><br><span class="line">        root-&gt;left = <span class="built_in">buildHelper</span>(preorder, inorder, preStart + <span class="number">1</span>, inStart, curIndex - <span class="number">1</span>, index);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildHelper</span>(preorder, inorder, preStart + curIndex - inStart + <span class="number">1</span>, curIndex + <span class="number">1</span>, inEnd, index);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/14/LeetCode-Daily-Question-29/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/tree/" rel="tag">tree</a></div></div></article></div><div class="paginator"><div class="next-wrap col-md-6 col-xs-6 col-md-offset-6 col-xs-offset-6"><a href="/page/2/" class="next-page">Next</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;秋&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>