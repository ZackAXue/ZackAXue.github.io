<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>MyBlog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">秋</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li><li class="menu-item"><a href="/about/" target="_self">ABOUT</a></li></ul></div></nav><main class="prince-container"><div class="articles"><article class="post-block"><h2 class="post-title"><a href="/2022/06/24/Meadow-Picnic-6-23/" class="post-link">Meadow Picnic 6.23</a></h2><div class="post-info">Jun 24th 2022</div><div class="post-entry"><h2 id="Meadow-Picnic-2"><a href="#Meadow-Picnic-2" class="headerlink" title="Meadow Picnic_2"></a>Meadow Picnic_2</h2><hr>
<p>久违的更新，新开辟的一个 tag，记录现在和以后的摄影作品（可能还算不上作品<br><img src="/images/6.23/pic1.jpg"></p>
<p><img src="/images/6.23/pic2.jpg"></p>
<p><img src="/images/6.23/pic3.jpg"></p>
<p><img src="/images/6.23/pic4.jpg"></p>
<p><img src="/images/6.23/pic5.jpg"></p>
<p><img src="/images/6.23/pic6.jpg"></p>
<p><img src="/images/6.23/pic7.jpg"></p>
<p><img src="/images/6.23/pic8.jpg"></p>
<p><img src="/images/6.23/pic9.jpg"></p>
</div><div class="post-meta"><a href="/2022/06/24/Meadow-Picnic-6-23/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Gallery/" rel="tag">Gallery</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/17/LeetCode-Daily-Question-30/" class="post-link">LeetCode Daily Question 30</a></h2><div class="post-info">May 17th 2022</div><div class="post-entry"><h2 id="5-月-14-日-每日一题"><a href="#5-月-14-日-每日一题" class="headerlink" title="5 月 14 日 每日一题"></a>5 月 14 日 每日一题</h2><hr>
<h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h3><p>One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as ‘#’.</p>
<p>For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where ‘#’ represents a null node.</p>
<p>Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree.</p>
<p>It is guaranteed that each comma-separated value in the string must be either an integer or a character ‘#’ representing null pointer.</p>
<p>You may assume that the input format is always valid.</p>
<p>For example, it could never contain two consecutive commas, such as “1,,3”.<br>Note: You are not allowed to reconstruct the tree.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: preorder = &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: preorder = &quot;1,#&quot;</span><br><span class="line">Output: false</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: preorder = &quot;9,#,#,1&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题有两种写法，我用了最笨的一种，每遇到两个#，将这两个 hash 和对应的 leaf node 删掉，然后添加一个#，要注意的是需要使用 while 循环，因为可能会在添加#之后形成新的满足 pop 要求的组合。要注意的是不能直接用 index 访问，因为可能会出现两位数字（92）。<br>另一种写法是聪明很多，因为 external node 数量必然比 internal 多 1，每遇到一个 val，counter++，遇到#，counter–，如果读完所有的 node 时，count 为-1，则有效（如果未读完所有 node，count 就为 1，意味着此时已经无法插入 node，则此 tree 无效）。<br><img src="/2022/05/17/LeetCode-Daily-Question-30/%E6%88%AA%E5%B1%8F2022-05-18%20%E4%B8%8B%E5%8D%888.44.49_31e0yfghz.png" alt="截屏2022-05-18 下午8.44.49"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSerialization</span><span class="params">(string preorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if it&#x27;s #</span></span><br><span class="line">        <span class="keyword">if</span>(preorder[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; preorder.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(preorder[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; preorder.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        preorder += <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        <span class="function">stringstream <span class="title">str</span><span class="params">(preorder)</span></span>;</span><br><span class="line">        string ele;</span><br><span class="line">        <span class="built_in">getline</span>(str, ele, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        vector&lt;string&gt; stack;</span><br><span class="line">        stack.<span class="built_in">push_back</span>(ele);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(str, ele, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">            stack.<span class="built_in">push_back</span>(ele);</span><br><span class="line">            <span class="keyword">if</span>(stack.<span class="built_in">back</span>() == <span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(stack.<span class="built_in">size</span>() &gt; <span class="number">2</span> &amp;&amp; stack.<span class="built_in">back</span>() == <span class="string">&quot;#&quot;</span> &amp;&amp; stack[stack.<span class="built_in">size</span>() - <span class="number">2</span>] == <span class="string">&quot;#&quot;</span> &amp;&amp; stack[stack.<span class="built_in">size</span>() - <span class="number">3</span>] != <span class="string">&quot;#&quot;</span> )&#123;</span><br><span class="line">                    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">                    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">                    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">                    stack.<span class="built_in">push_back</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; stack.<span class="built_in">back</span>() == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidSerialization</span><span class="params">(string p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream ss&#123;p&#125;;</span><br><span class="line">	<span class="type">int</span> c&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>( ; c!=<span class="number">-1</span> <span class="keyword">and</span> !ss.<span class="built_in">eof</span>(); <span class="built_in">getline</span>(ss, p, <span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        p[<span class="number">0</span>]==<span class="string">&#x27;#&#x27;</span> ? --c : ++c；</span><br><span class="line">	<span class="keyword">return</span> c==<span class="number">-1</span> <span class="keyword">and</span> ss.<span class="built_in">eof</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/17/LeetCode-Daily-Question-30/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Tree/" rel="tag">Tree</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/14/LeetCode-Daily-Question-29/" class="post-link">LeetCode Daily Question 29</a></h2><div class="post-info">May 14th 2022</div><div class="post-entry"><h2 id="5-月-14-日-每日一题"><a href="#5-月-14-日-每日一题" class="headerlink" title="5 月 14 日 每日一题"></a>5 月 14 日 每日一题</h2><hr>
<h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h3><p>Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7]</span><br><span class="line">Output: [3,9,20,null,null,15,7]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题使用递归的写法，首先思考递归公式：</p>
<ol>
<li>将 preoder 的局部第一位设为 root（left 区域的第一个 preorder 或 right 区域的第一个 preoder，因此需要一个 prestart 参数）。</li>
<li>找到该 preorder element 在 inorder 中的 index。</li>
<li>针对该 preorder element 的 left 区域进入子问题（因此需要 instart 和 inEnd 参数）。</li>
<li>针对该 preoder element 的 right 区域进入子问题。</li>
</ol>
<p>第二步思考临界条件：<br>prestart &gt;&#x3D; preorder.size() || instart &gt; inend 时返回 nullptr（无 node）</p>
<p>第三步实现代码。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; index;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; inorder.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            index[inorder[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">buildHelper</span>(preorder, inorder, <span class="number">0</span>, <span class="number">0</span>, <span class="built_in">int</span>(inorder.<span class="built_in">size</span>() - <span class="number">1</span>), index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">buildHelper</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder, <span class="type">int</span> preStart, <span class="type">int</span> inStart, <span class="type">int</span> inEnd, unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; &amp;index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(preStart &gt;= preorder.<span class="built_in">size</span>() || inStart &gt; inEnd)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode *root = <span class="keyword">new</span> TreeNode&#123;preorder[preStart], <span class="literal">nullptr</span>, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">        <span class="type">int</span> curIndex = index[preorder[preStart]];</span><br><span class="line">        root-&gt;left = <span class="built_in">buildHelper</span>(preorder, inorder, preStart + <span class="number">1</span>, inStart, curIndex - <span class="number">1</span>, index);</span><br><span class="line">        root-&gt;right = <span class="built_in">buildHelper</span>(preorder, inorder, preStart + curIndex - inStart + <span class="number">1</span>, curIndex + <span class="number">1</span>, inEnd, index);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/14/LeetCode-Daily-Question-29/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Tree/" rel="tag">Tree</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/11/LeetCode-Daily-Question-28/" class="post-link">LeetCode Daily Question 28</a></h2><div class="post-info">May 11th 2022</div><div class="post-entry"><h2 id="5-月-11-日-每日一题"><a href="#5-月-11-日-每日一题" class="headerlink" title="5 月 11 日 每日一题"></a>5 月 11 日 每日一题</h2><hr>
<h3 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h3><p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Recursive 写法：<br>首先思考问题与子问题的递归关系，可分为三种 case，第一种是只有一个 node，必然 true；第二种是三个 node，需要满足 left-&gt;val &#x3D;&#x3D; right-&gt;val；第三种是 height 大于 3 的 completed tree，需要满足 left-&gt;val &#x3D;&#x3D; right-&gt;val 并且 left-&gt;left tree 与 right-&gt;right tree 相同，left-&gt;right 与 right-&gt;left 相同。<br>之后思考 base case，left&#x2F;right 有一个空或全空。<br>最后将以上归纳为函数代码(首先将 root-&gt;left，right）传入函数可以自然判断前两种 case。</p>
<p>Iterative 写法：<br>逻辑类似 BSF，首先将 root-&gt;left,right 放入 queue，while 判断条件为 queue 非空，在 while 内判断 val 并且按递归 case3 的顺序 push 进 queue.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SymmetricHelper</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SymmetricHelper</span><span class="params">(TreeNode *left, TreeNode *right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left || !right)</span><br><span class="line">            <span class="keyword">return</span> left == right;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val != right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SymmetricHelper</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">SymmetricHelper</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; queue;</span><br><span class="line">        queue.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        queue.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *left = queue.<span class="built_in">front</span>(); queue.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode *right = queue.<span class="built_in">front</span>(); queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!left || !right) <span class="keyword">return</span> left == right;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            queue.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            queue.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            queue.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            queue.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/11/LeetCode-Daily-Question-28/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/tree/" rel="tag">tree</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/10/LeetCode-Daily-Question-27/" class="post-link">LeetCode Daily Question 27</a></h2><div class="post-info">May 10th 2022</div><div class="post-entry"><h2 id="5-月-10-日-每日一题"><a href="#5-月-10-日-每日一题" class="headerlink" title="5 月 10 日 每日一题"></a>5 月 10 日 每日一题</h2><hr>
<h3 id="题目：99-Recover-Binary-Search-Tree"><a href="#题目：99-Recover-Binary-Search-Tree" class="headerlink" title="题目：99. Recover Binary Search Tree"></a>题目：99. Recover Binary Search Tree</h3><p>You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,1,4,null,null,2]</span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line">Explanation: 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题核心是利用 inorder traversal 检测错误点（BSF 的 inorder 应该为从小到大），如果检测到两组顺序不同的 node，则为第一组 node 的第一个位置和第二组 node 的第二个位置。因此需要两个 pointer first 和 second 记录这两个位置。需要注意的是 prev 的初始值应该为 infinitMin。<br>注意 prev 初始为 infmin</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *firstRemove, *secondRemove, *prev;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        prev = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MIN);</span><br><span class="line">        <span class="built_in">inorderHelper</span>(root);</span><br><span class="line">        <span class="built_in">swap</span>(firstRemove-&gt;val, secondRemove-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderHelper</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorderHelper</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(firstRemove == <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; prev-&gt;val)</span><br><span class="line">            firstRemove = prev;</span><br><span class="line">        <span class="keyword">if</span>(firstRemove != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; prev-&gt;val)</span><br><span class="line">            secondRemove = root;</span><br><span class="line">        prev = root;</span><br><span class="line">        <span class="built_in">inorderHelper</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/10/LeetCode-Daily-Question-27/" class="article-more">Read More</a></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/09/LeetCode-Daily-Question-26/" class="post-link">LeetCode Daily Question 26</a></h2><div class="post-info">May 9th 2022</div><div class="post-entry"><h2 id="5-月-9-日-每日一题"><a href="#5-月-9-日-每日一题" class="headerlink" title="5 月 9 日 每日一题"></a>5 月 9 日 每日一题</h2><hr>
<h3 id="题目：237-Delete-Node-in-a-Linked-List"><a href="#题目：237-Delete-Node-in-a-Linked-List" class="headerlink" title="题目：237. Delete Node in a Linked List"></a>题目：237. Delete Node in a Linked List</h3><p>Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly.</p>
<p>It is guaranteed that the node to be deleted is not a tail node in the list.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道 easy 题，先将下一个 node 的信息保存到该 node，然后删除下一 node。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     ListNode *next;</span><br><span class="line">     <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        ListNode* forwarding = node-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> node-&gt;next;</span><br><span class="line">        node-&gt;next = forwarding;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/09/LeetCode-Daily-Question-26/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/linkList/" rel="tag">linkList</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/08/LeetCode-Daily-Question-25/" class="post-link">LeetCode Daily Question 25</a></h2><div class="post-info">May 8th 2022</div><div class="post-entry"><h2 id="5-月-8-日-每日一题"><a href="#5-月-8-日-每日一题" class="headerlink" title="5 月 8 日 每日一题"></a>5 月 8 日 每日一题</h2><hr>
<h3 id="题目：141-Linked-List-Cycle"><a href="#题目：141-Linked-List-Cycle" class="headerlink" title="题目：141. Linked List Cycle"></a>题目：141. Linked List Cycle</h3><p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p>
<p>Return true if there is a cycle in the linked list. Otherwise, return false.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>两种思路，快慢指针和 hashmap&#x2F;set，hashmap 需要注意 value 可能重复所以 key 应该使用 ListNode*类型。快慢指针需要考虑 head 为 nullptr，linkList 只有两个的 edge case（建议提前列出 0 1 2 3 个 Node 的情况。</p>
<p>需要注意的是，unorder_map 的 count 函数，如果该 key 存在，返回 1，不存在返回 0。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next )&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/08/LeetCode-Daily-Question-25/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/linkList/" rel="tag">linkList</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/07/LeetCode-Daily-Question-24/" class="post-link">LeetCode Daily Question 24</a></h2><div class="post-info">May 7th 2022</div><div class="post-entry"><h2 id="5-月-7-日-每日一题"><a href="#5-月-7-日-每日一题" class="headerlink" title="5 月 7 日 每日一题"></a>5 月 7 日 每日一题</h2><hr>
<h3 id="题目：284-Peeking-Iterator"><a href="#题目：284-Peeking-Iterator" class="headerlink" title="题目：284. Peeking Iterator"></a>题目：284. Peeking Iterator</h3><p>Given the head of a singly linked list and two integers left and right where left &lt;&#x3D; right, reverse the nodes of the list from position left to position right, and return the reversed list.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">Output: [1,4,3,2,5]</span><br><span class="line">Example 2:</span><br><span class="line">Input: head = [5], left = 1, right = 1</span><br><span class="line">Output: [5]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>I. Dummy Node<br>用于避免 reverse 的 left 为 head 的 edge case，结束时返回 dummy node 的 next 即可。</p>
<p>II. 移动指针，将指针指向 left，并且需要记录 left 的前一个 node，以便结束时 connect。需要注意的是循环的运行次数应该为 left - 1.</p>
<p>III. 对要求区域进行 reverse，需要记录 curr，prev 和 forwarding，流程为，首先记录 current node 的 next，然后将 current node 的 next 指向 prev，然后将 prev 更新为 current node，current node 更新为 forwarding node。reverse 的次数为 right - left + 1，这是因为第一次循环 prev 为 nullptr。</p>
<p>IV. 连接 reverse 区域与其余区域，此时 current 指向 node after right，并且 leftPrev 的 next 为 reverse 前的 left。首先将 reverse 前的 left 的 next 指向 current。然后将 leftPrev 的 next 指向 prev（right）。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//dummy node</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="comment">//go to left</span></span><br><span class="line">        ListNode *leftPrev = dummy;</span><br><span class="line">        ListNode *cur = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            leftPrev = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;<span class="comment">//now cur points to left</span></span><br><span class="line">        <span class="comment">//reverse from left to right</span></span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            ListNode* forwarding = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = forwarding;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">        leftPrev-&gt;next-&gt;next = cur;</span><br><span class="line">        leftPrev-&gt;next = prev;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/07/LeetCode-Daily-Question-24/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/linkList/" rel="tag">linkList</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/06/LeetCode-Daily-Question-23/" class="post-link">LeetCode Daily Question 23</a></h2><div class="post-info">May 6th 2022</div><div class="post-entry"><h2 id="5-月-6-日-每日一题"><a href="#5-月-6-日-每日一题" class="headerlink" title="5 月 6 日 每日一题"></a>5 月 6 日 每日一题</h2><hr>
<h3 id="题目：284-Peeking-Iterator"><a href="#题目：284-Peeking-Iterator" class="headerlink" title="题目：284. Peeking Iterator"></a>题目：284. Peeking Iterator</h3><p>Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations.</p>
<p>Implement the PeekingIterator class:</p>
<p>PeekingIterator(Iterator<int> nums) Initializes the object with the given integer iterator iterator.<br>int next() Returns the next element in the array and moves the pointer to the next element.<br>boolean hasNext() Returns true if there are still elements in the array.<br>int peek() Returns the next element in the array without moving the pointer.<br>Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions.</int></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;PeekingIterator&quot;, &quot;next&quot;, &quot;peek&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;]</span><br><span class="line">[[[1, 2, 3]], [], [], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, 1, 2, 2, 3, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]</span><br><span class="line">peekingIterator.next();    // return 1, the pointer moves to the next element [1,2,3].</span><br><span class="line">peekingIterator.peek();    // return 2, the pointer does not move [1,2,3].</span><br><span class="line">peekingIterator.next();    // return 2, the pointer moves to the next element [1,2,3]</span><br><span class="line">peekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]</span><br><span class="line">peekingIterator.hasNext(); // return False</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题没什么好说的，看懂题就能做出来，奈何我没看懂题…</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PeekingIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> isHasNext;</span><br><span class="line">    <span class="type">int</span> nextVal;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PeekingIterator</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums) : <span class="built_in">Iterator</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// Initialize any member here.</span></span><br><span class="line">        <span class="comment">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class="line">        <span class="comment">// You should only use the Iterator interface methods.</span></span><br><span class="line">        isHasNext = Iterator::<span class="built_in">hasNext</span>();</span><br><span class="line">        <span class="keyword">if</span>(isHasNext)</span><br><span class="line">            nextVal = Iterator::<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line">    <span class="comment">// Override them if needed.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> currNext = nextVal;</span><br><span class="line">        isHasNext = Iterator::<span class="built_in">hasNext</span>();</span><br><span class="line">        <span class="keyword">if</span>(isHasNext)</span><br><span class="line">            nextVal = Iterator::<span class="built_in">next</span>();</span><br><span class="line">        <span class="keyword">return</span> currNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHasNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/06/LeetCode-Daily-Question-23/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/06/LeetCode-Daily-Question-22/" class="post-link">LeetCode Daily Question 22</a></h2><div class="post-info">May 6th 2022</div><div class="post-entry"><h2 id="5-月-6-日-每日一题"><a href="#5-月-6-日-每日一题" class="headerlink" title="5 月 6 日 每日一题"></a>5 月 6 日 每日一题</h2><hr>
<h3 id="题目：169-Majority-Element"><a href="#题目：169-Majority-Element" class="headerlink" title="题目：169. Majority Element"></a>题目：169. Majority Element</h3><p>Given an array nums of size n, return the majority element.</p>
<p>The majority element is the element that appears more than ⌊n &#x2F; 2⌋ times. You may assume that the majority element always exists in the array.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题使用 Boyer–Moore majority vote algorithm，因为条件是必然存在 majority，本质可以理解为为每一个元素寻找一个不同的元素进行配对，应该存在 n&#x2F;2 个 pair，但 majority 一定出现多于 n&#x2F;2 次，所以最终剩余的无法配对的元素就是 majority。<img src="https://i.imgur.com/kv3Gl4Q.png" alt="截屏2022-05-06 下午11.44.32"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> majority = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= <span class="number">1</span>)</span><br><span class="line">                count += (num == majority) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/06/LeetCode-Daily-Question-22/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article></div><div class="paginator"><div class="next-wrap col-md-6 col-xs-6 col-md-offset-6 col-xs-offset-6"><a href="/page/2/" class="next-page">Next</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;秋&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>