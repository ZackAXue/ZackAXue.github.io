<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>MyBlog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">秋</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li><li class="menu-item"><a href="/about/" target="_self">ABOUT</a></li></ul></div></nav><main class="prince-container"><div class="articles"><article class="post-block"><h2 class="post-title"><a href="/2022/12/12/Nothern-Michigan/" class="post-link">Nothern Michigan</a></h2><div class="post-info">Dec 12th 2022</div><div class="post-entry"></div><div class="post-meta"><a href="/2022/12/12/Nothern-Michigan/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/written-research-tutorial/" rel="tag">written research tutorial</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/12/07/CMPLXSYS501-final-proj/" class="post-link">Network Motif Analysis for Functional Brain Network Under Different Intelligence Tasks</a></h2><div class="post-info">Dec 7th 2022</div><div class="post-entry"><p><img src="/images/501_final_project/neuron.jpg"></p>
<h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a><strong>Preface</strong></h1><p>This research guide consists of two parts. The text part covers the background of the project, introduction and motif-find algorithm analysis. The video part covers the pre-processing method for fMRI of brain regions, ROI selection.</p>
<h1 id="Backgraound"><a href="#Backgraound" class="headerlink" title="Backgraound"></a><strong>Backgraound</strong></h1><p>In the study of human intelligence, researchers have long sought to understand the relationship between the functional organization of the brain and individual cognitive abilities. One approach to this problem is to use functional MRI to obtain the brain network in response to a particular stimulus, and then apply algorithms based on graph theory to analyze the structure and function of the network. In this project, two brain network modeling methods were implemented: regularized inverse covariance(Schmidt, 2006) and Conservative PC (CPC) (Ramsey et al, 2006). Three motif-searching methods were also used to analyze changes in network motif over time: FANMOD (Wernicke and Rasche, 2006), MAVisto (Schreiber and Schwöbbermeyer, 2005), and GK (Grochow et al, 2007). These algorithms were applied to data collected from participants performing twelve subtasks from an established intelligence test in order to uncover patterns and temporal information in the brain network. The fMRI dataset under 12 subtasks of this project is from Openneuro (<a target="_blank" rel="noopener" href="https://openneuro.org/">https://openneuro.org/</a>) based on the paper(Soreq et al, 2021). The process of the dataset uses SPM12(<a target="_blank" rel="noopener" href="https://www.fil.ion.ucl.ac.uk/spm/software/spm12/">https://www.fil.ion.ucl.ac.uk/spm/software/spm12/</a>), Marsbar (<a target="_blank" rel="noopener" href="https://marsbar-toolbox.github.io/">https://marsbar-toolbox.github.io/</a>) and AFNI (<a target="_blank" rel="noopener" href="https://afni.nimh.nih.gov/">https://afni.nimh.nih.gov/</a>). </p>
<h1 id="Why-I-Made-This"><a href="#Why-I-Made-This" class="headerlink" title="Why I Made This"></a><strong>Why I Made This</strong></h1><p><img src="/images/501_final_project/network.png"><br><strong>Fig:Network generated from fMRI data by L1 precision algorithm</strong><br>I am an undergraduate student majoring in Computer Science at the University of Michigan. I also have a minor in Complex Systems and Statistics. In the fall semester of 2022, I took the class CONMPLXSYS501 Introduction to complex systems. I was fascinated by many of the concepts in complex systems, especially the section on network analysis, especially for its application in neuroscience. Understanding how the human brain works may help us to explore the potential of artificial intelligence and to accomplish real artificial intelligence. Therefore, I chose the analysis of brain networks for my final project. </p>
<p>So, I decided to focus on the analysis of brain networks for my final project, but found the project to be more challenging than I had anticipated. In order to better understand the topic, I spent a considerable amount of time researching neuroscience concepts and learning about the processing of fMRI data and the pros and cons of different algorithms for network modeling. Despite facing limited personal computing resources and other challenges, I persevered and completed my project. This experience has given me a deeper appreciation for the rigors of scientific research and the thrill of exploring uncharted territory.</p>
<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a><strong>Introduction</strong></h1><p>A network motif is a small, recurring pattern that occurs within the structure of a network. These patterns are thought to play a key role in the functioning of the network by providing a basic building block for the organization and operation of the system. For example, in a biological network, a motif might represent a specific interaction between proteins that has a particular biological function. To do this in brain, researchers use functional magnetic resonance imaging (fMRI) data to construct brain networks, and then apply algorithms based on graph theory to search for network motifs. However, motif research on Brain Network focus more on Resting-State network or under single task.<br>Static data cannot help us understand the underlying logic of how the brain operates. To solve this problem, I modeled brain fMRI for subjects participating in each of the 12 intelligence tests, and perform motif finding algorithm to them. This can help to reveal underlying organizational principles in brain and to understand how these patterns may be related to cognitive processes and behavior.</p>
<h1 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a><strong>Approach</strong></h1><p>The project pipeline consists of the following three parts.</p>
<ol>
<li>pre-processing of FMRI timing data and selection of region of interest (ROI)</li>
<li>acquiring the voxel timing signal and obtaining the brain network by network modeling.</li>
<li>finding the feature nodes in the network using the motif finding algorithm.<br><img src="/images/501_final_project/pipeline.png"></li>
</ol>
<p><strong>Fig: pipeline of this project, containing pre-processing, network-modeling and motif-finding</strong></p>
<h2 id="Introduction-to-Basic-Concepts"><a href="#Introduction-to-Basic-Concepts" class="headerlink" title="Introduction to Basic Concepts"></a><strong>Introduction to Basic Concepts</strong></h2><iframe height="598" width="660" src="https://player.youku.com/embed/XNTkyODg1MjI4MA==" frameborder="0" 'allowfullscreen'></iframe>

<h2 id="fMRI-Pre-processing-amp-ROI-Selection"><a href="#fMRI-Pre-processing-amp-ROI-Selection" class="headerlink" title="fMRI Pre-processing &amp; ROI Selection"></a><strong>fMRI Pre-processing &amp; ROI Selection</strong></h2><iframe height="598" width="660" src="https://player.youku.com/embed/XNTkyNjc0NjI0OA==" frameborder="0" 'allowfullscreen'></iframe>

<h2 id="Network-modeling-amp-Motif-Finding"><a href="#Network-modeling-amp-Motif-Finding" class="headerlink" title="Network-modeling &amp; Motif Finding"></a><strong>Network-modeling &amp; Motif Finding</strong></h2><h3 id="Network-modeling"><a href="#Network-modeling" class="headerlink" title="Network-modeling"></a><strong>Network-modeling</strong></h3><p>In this study, the time-series data obtained from the previous step are fed into two algorithms, L1 precision(Schmidt, 2006) and Conservative PC (CPC)(Ramsey et al, 2006), to obtain undirected and directed graphs of brain network connectivity. L1 precision is a method that minimizes the log determinant of the matrix of connectivity weights while constraining the matrix to match the covariance of the input time-series data. This regularization helps to reduce the influence of noise in the data when the number of time points is limited (Smith et al, 2011). CPC is a variant of the PC algorithm that infers causal relationships between the time-series data. It uses a set of rules to determine the orientation of the edges in the network, with the goal of limiting the number of false orientations(Ramsey et al, 2006; Smith et al, 2010).  Since  L1 precision is effective at identifying direct relationships between the time-series data, while CPC is particularly good at inferring causal relationships. By applying both methods, this study aims to uncover the different topological properties of functional connectivity in the brain.</p>
<h3 id="Motif-finding"><a href="#Motif-finding" class="headerlink" title="Motif-finding"></a><strong>Motif-finding</strong></h3><p>Network motif-finding algorithms are a class of computational methods used to identify recurrent patterns of connections within a network. These algorithms can be distinguished into two broad categories: frequency-based and significance-based. Frequency-based algorithms determine the number of occurrences of each motif within a network and report the most frequent motifs. In contrast, significance-based algorithms evaluate whether the observed number of occurrences of each motif is statistically significant compared to a null model of the network. In this study, three motif search algorithms or packages are used to identify network motifs in the brain connectivity data: FANMOD, MAVisto, and Grochow-Kellis. </p>
<ol>
<li>FANMOD (Wernicke and Rasche, 2006) is an efficient algorithm that uses unbiased nodes to sample the network and ensures that each subgraph is only searched once, without generating redundant or meaningless subgraphs. It employs a new analysis method called DIRECT to assess the significance of identified subgraphs, rather than using random networks as null models. </li>
<li>MAVisto (Wernicke and Rasche, 2006), on the other hand, uses a pattern tree and the downward closure property to build subnodes by adding edges one by one according to the root nodes. It then evaluates whether the current subgraph is below a predefined threshold and, if so, discards any remaining new or reversed edges until there are none left. </li>
<li>The Grochow-Kellis (Grochow et al, 2007) algorithm aims to find all possible mappings of a given query graph in the network, which it does by first calculating the symmetric breaking condition of the query graph and then using the branch and bound method to search for all possible mappings that meet this condition. These three algorithms represent different classes of motif search methods and can be used to evaluate and compare the results of motif searches in the brain connectivity data.</li>
</ol>
<h1 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a><strong>Conclusion</strong></h1><p>In this study, a total of 15 subjects are selected to undergo motif analysis. For each subject, 12 undirected graphs are inferred from L1 precision and 12 directed graphs are inferred from Conservative PC (CPC) for each of the 12 tasks. Then, for each graph, motif searching is performed using the three algorithms described above to identify motifs with 3, 4, and 5 nodes. The results from all 15 subjects are averaged for each task to obtain the motif distribution for 3, 4, and 5 nodes from both the undirected and directed graphs. This allows for the comparison of the unique motif search results for each task.</p>
<p>After combining the results from the FANMOD, MAVisto, and Grochow-Kellis algorithms, it was found that the dominant motifs identified by these methods are similar. Therefore, the results from FANMOD were used for further analysis.<br><img src="/images/501_final_project/fanmod.png"><br>In the results obtained from the undirected network, only motifs with a p-value &lt;&#x3D; 0.05 and a frequency &gt;&#x3D; 0.5% were selected for further analysis. Figure 3 shows the distribution of these motifs for each task, with each row representing a different task and each column representing a different motif. The values in the table are the average frequency of each motif across all tasks, with each value being subtracted from the average to show how far a given motif is from the average value across all tasks. </p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a><strong>Reference</strong></h1><ul>
<li>Grochow, J. A., &amp; Kellis, M. (2007, April). Network motif discovery using subgraph enumeration and symmetry-breaking. In Annual International Conference on Research in Computational Molecular Biology (pp. 92-106). Springer, Berlin, Heidelberg.</li>
<li>Ramsey, J. Zhang, J. Spirtes, P. (2006). Adjacency-faithfulness and conservative causal inference. Proceedings of the 22nd Annual Conference on Uncertainty in Artificial Intelligence.  </li>
<li>Schmidt, M. (2006) L1precision: Matlab code for MAP estimation of Gaussian Graphical Model Precision with L1-regularizer. Retrieved from <a target="_blank" rel="noopener" href="http://www.cs.ubc.ca/~schmidtm/Software/L1precision.html">http://www.cs.ubc.ca/~schmidtm/Software/L1precision.html</a>.</li>
<li>Schreiber, F., &amp; Schwöbbermeyer, H. (2005). MAVisto: a tool for the exploration of network motifs. Bioinformatics, 21(17), 3572-3574.</li>
<li>Soreq, E., Violante, I. R., Daws, R. E., &amp; Hampshire, A. (2021). Neuroimaging evidence for a network sampling theory of individual differences in human intelligence test performance. Nature communications, 12(1), 1-13.</li>
<li>Wernicke, S., &amp; Rasche, F. (2006). FANMOD: a tool for fast network motif detection. Bioinformatics, 22(9), 1152-1153.</li>
</ul>
</div><div class="post-meta"><a href="/2022/12/07/CMPLXSYS501-final-proj/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/written-research-tutorial/" rel="tag">written research tutorial</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/08/25/great-smoky-mountain/" class="post-link">Great Smoky Mountain</a></h2><div class="post-info">Aug 25th 2022</div><div class="post-entry"><p><img src="/images/great_smoky_mountain/pic1.jpg"><br><img src="/images/great_smoky_mountain/pic2.jpg"><br><img src="/images/great_smoky_mountain/pic3.jpg"><br><img src="/images/great_smoky_mountain/pic4.jpg"><br><img src="/images/great_smoky_mountain/pic5.jpg"></p>
</div><div class="post-meta"><a href="/2022/08/25/great-smoky-mountain/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Gallery/" rel="tag">Gallery</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/07/26/Chicago/" class="post-link">Chicago</a></h2><div class="post-info">Jul 26th 2022</div><div class="post-entry"><p><img src="/images/Chicago/pic1.jpg"><br><img src="/images/Chicago/pic2.jpg"><br><img src="/images/Chicago/pic3.jpg"><br><img src="/images/Chicago/pic4.jpg"><br><img src="/images/Chicago/pic5.jpg"><br><img src="/images/Chicago/pic6.jpg"><br><img src="/images/Chicago/pic7.jpg"><br><img src="/images/Chicago/pic8.jpg"><br><img src="/images/Chicago/pic9.jpg"><br><img src="/images/Chicago/pic10.jpg"></p>
</div><div class="post-meta"><a href="/2022/07/26/Chicago/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Gallery/" rel="tag">Gallery</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/07/21/LeetCode-Daily-Question-34/" class="post-link">LeetCode-Daily-Question-34</a></h2><div class="post-info">Jul 21st 2022</div><div class="post-entry"><h2 id="7-月-21-日-每日一题"><a href="#7-月-21-日-每日一题" class="headerlink" title="7 月 21 日 每日一题"></a>7 月 21 日 每日一题</h2><hr>
<h3 id="17-Letter-Combinations-of-a-Phone-Number"><a href="#17-Letter-Combinations-of-a-Phone-Number" class="headerlink" title="17. Letter Combinations of a Phone Number"></a>17. Letter Combinations of a Phone Number</h3><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent. Return the answer in any order.</p>
<p>A mapping of digits to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: digits = &quot;23&quot;</span><br><span class="line">Output: [&quot;ad&quot;,&quot;ae&quot;,&quot;af&quot;,&quot;bd&quot;,&quot;be&quot;,&quot;bf&quot;,&quot;cd&quot;,&quot;ce&quot;,&quot;cf&quot;]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Using bsf (a queue) or a temp vector to store the intermediate status of the combinations.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">letterCombinations</span><span class="params">(string digits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(digits.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        vector&lt;string&gt; phone = &#123;<span class="string">&quot;0&quot;</span>, <span class="string">&quot;1&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;def&quot;</span>, <span class="string">&quot;ghi&quot;</span>, <span class="string">&quot;jkl&quot;</span>, <span class="string">&quot;mno&quot;</span>, <span class="string">&quot;pqrs&quot;</span>, <span class="string">&quot;tuv&quot;</span>, <span class="string">&quot;wxyz&quot;</span>&#125;;</span><br><span class="line">        queue&lt;string&gt; bsf;</span><br><span class="line">        vector&lt;string&gt; ans;</span><br><span class="line">        bsf.<span class="built_in">push</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span>(!bsf.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            string s = bsf.<span class="built_in">front</span>();</span><br><span class="line">            bsf.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(s.<span class="built_in">length</span>() == digits.<span class="built_in">length</span>())</span><br><span class="line">                ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">char</span> c: phone[digits[s.<span class="built_in">length</span>()] - <span class="string">&#x27;0&#x27;</span>])</span><br><span class="line">                    bsf.<span class="built_in">push</span>(s + c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/07/21/LeetCode-Daily-Question-34/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/bfs/" rel="tag">bfs</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/07/20/LeetCode-Daily-Question-33/" class="post-link">LeetCode-Daily-Question-33</a></h2><div class="post-info">Jul 20th 2022</div><div class="post-entry"><h2 id="7-月-20-日-每日一题"><a href="#7-月-20-日-每日一题" class="headerlink" title="7 月 20 日 每日一题"></a>7 月 20 日 每日一题</h2><hr>
<h3 id="543-Diameter-of-Binary-Tree"><a href="#543-Diameter-of-Binary-Tree" class="headerlink" title="543. Diameter of Binary Tree"></a>543. Diameter of Binary Tree</h3><p>Given the root of a binary tree, return the length of the diameter of the tree.</p>
<p>The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.</p>
<p>The length of a path between two nodes is represented by the number of edges between them.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5]</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>It is similar to height of tree. Diameter &#x3D; Height of the left subtree + Height of the right subtree. Keep track of the maxDiameter during traversal by an extra parameter and get the height of the tree.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> diameter = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">diaHelper</span>(root, diameter);</span><br><span class="line">        <span class="keyword">return</span> diameter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">diaHelper</span><span class="params">(TreeNode* node, <span class="type">int</span>&amp; diameter)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">diaHelper</span>(node-&gt;left, diameter);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">diaHelper</span>(node-&gt;right, diameter);</span><br><span class="line">        diameter = <span class="built_in">max</span>(diameter, left + right);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left,right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/07/20/LeetCode-Daily-Question-33/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/recursive/" rel="tag">recursive</a>, <a class="tag-link" href="/tags/tree/" rel="tag">tree</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/07/19/LeetCode-Daily-Question-32/" class="post-link">LeetCode Daily-Question 32</a></h2><div class="post-info">Jul 19th 2022</div><div class="post-entry"><h2 id="7-月-19-日-每日一题"><a href="#7-月-19-日-每日一题" class="headerlink" title="7 月 19 日 每日一题"></a>7 月 19 日 每日一题</h2><hr>
<h3 id="117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="117. Populating Next Right Pointers in Each Node II"></a>117. Populating Next Right Pointers in Each Node II</h3><p>Given a binary tree</p>
<p>struct Node {<br>int val;<br>Node *left;<br>Node *right;<br>Node *next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,null,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,7,#]</span><br><span class="line">Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#x27;#&#x27; signifying the end of each level.</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>The difference between 116 and 117 is that 117 is not a perfect binary tree, which means it cannot be simply solved by recursive.</p>
<p>The direct way is to use iterative BSF. Note that when reach to null, it’s time to move to the next level and add a nullptr to the end of the queue(for the next level end).</p>
<p>There is a O(1) space complexity way, which is a bit similar to double pointer. The detail is in comments of code. Note the when proceed the current level(currParent), the next has been proceed by last while loop.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Way 1:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        queue&lt;Node*&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            Node* curr = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!curr)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left)</span><br><span class="line">                q.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right)</span><br><span class="line">                q.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Way 2:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        Node *currParent = root;</span><br><span class="line">        Node *baseChild;</span><br><span class="line">        Node *currChild;</span><br><span class="line">        Node *nextChild;</span><br><span class="line">        <span class="keyword">while</span>(currParent)&#123;</span><br><span class="line">            <span class="comment">//reach to a parent with at least one child</span></span><br><span class="line">            <span class="keyword">while</span>(currParent-&gt;next &amp;&amp; !currParent-&gt;left &amp;&amp; !currParent-&gt;right)</span><br><span class="line">                currParent = currParent-&gt;next;</span><br><span class="line">            <span class="comment">//set baseChild and currChild to the first child of the next level</span></span><br><span class="line">            currChild = baseChild = currParent-&gt;left ? currParent-&gt;left : currParent-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(currChild)&#123;</span><br><span class="line">                <span class="comment">//if currChild is left child and have right sibling</span></span><br><span class="line">                <span class="keyword">if</span>(currParent-&gt;right &amp;&amp; currParent-&gt;right != currChild)&#123;</span><br><span class="line">                    nextChild = currParent-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//move to the adjacent parent</span></span><br><span class="line">                    currParent = currParent-&gt;next;</span><br><span class="line">                    <span class="keyword">while</span>(currParent &amp;&amp; !currParent-&gt;left &amp;&amp; !currParent-&gt;right)&#123;</span><br><span class="line">                        currParent = currParent-&gt;next;</span><br><span class="line">                        <span class="comment">//now currParent has pointed to the next Parent</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//if not reach to the end</span></span><br><span class="line">                    <span class="keyword">if</span>(currParent)&#123;</span><br><span class="line">                        nextChild = currParent-&gt;left ? currParent-&gt;left : currParent-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//if reach to the end</span></span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//if reach to the end of this level</span></span><br><span class="line">                        nextChild = <span class="literal">nullptr</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                currChild-&gt;next = nextChild;</span><br><span class="line">                currChild = nextChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//move to the next level</span></span><br><span class="line">            currParent = baseChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/07/19/LeetCode-Daily-Question-32/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/bfs/" rel="tag">bfs</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/tree/" rel="tag">tree</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/07/18/LeetCode-Daily-Question-31/" class="post-link">LeetCode Daily Question 31</a></h2><div class="post-info">Jul 18th 2022</div><div class="post-entry"><h2 id="7-月-18-日-每日一题"><a href="#7-月-18-日-每日一题" class="headerlink" title="7 月 18 日 每日一题"></a>7 月 18 日 每日一题</h2><hr>
<p>时隔两个月的更新，之后会恢复每日一题，频率定为每周六题</p>
<h3 id="116-Populating-Next-Right-Pointers-in-Each-Node"><a href="#116-Populating-Next-Right-Pointers-in-Each-Node" class="headerlink" title="116. Populating Next Right Pointers in Each Node"></a>116. Populating Next Right Pointers in Each Node</h3><p>You are given a perfect binary tree where all leaves are on the same level, and every parent has two children. The binary tree has the following definition:</p>
<p>struct Node {<br>int val;<br>Node *left;<br>Node *right;<br>Node *next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,6,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,6,7,#]</span><br><span class="line">Explanation: Given the above perfect binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#x27;#&#x27; signifying the end of each level.</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>For recursive, firstly, point root-&gt;left-&gt;next to root-&gt;right-&gt;next. Then use root’s next arrow to find right children’s buddy in the neighboring tree. Take care of current level’s children’s next problem and then move down to children subtree.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    Node* left;</span><br><span class="line">    Node* right;</span><br><span class="line">    Node* next;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val) : <span class="built_in">val</span>(_val), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _val, Node* _left, Node* _right, Node* _next)</span><br><span class="line">        : <span class="built_in">val</span>(_val), <span class="built_in">left</span>(_left), <span class="built_in">right</span>(_right), <span class="built_in">next</span>(_next) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)&#123;</span><br><span class="line">            root-&gt;left-&gt;next = root-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;next)&#123;</span><br><span class="line">                root-&gt;right-&gt;next = root-&gt;next-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">connect</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">connect</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/07/18/LeetCode-Daily-Question-31/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/tree/" rel="tag">tree</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/06/24/Meadow-Picnic-6-23/" class="post-link">Meadow Picnic 6.23</a></h2><div class="post-info">Jun 24th 2022</div><div class="post-entry"><h2 id="Meadow-Picnic-2"><a href="#Meadow-Picnic-2" class="headerlink" title="Meadow Picnic_2"></a>Meadow Picnic_2</h2><hr>
<p>久违的更新，新开辟的一个 tag，记录现在和以后的摄影作品（可能还算不上作品<br><img src="/images/6.23/pic1.jpg"></p>
<p><img src="/images/6.23/pic2.jpg"></p>
<p><img src="/images/6.23/pic3.jpg"></p>
<p><img src="/images/6.23/pic4.jpg"></p>
<p><img src="/images/6.23/pic5.jpg"></p>
<p><img src="/images/6.23/pic6.jpg"></p>
<p><img src="/images/6.23/pic7.jpg"></p>
<p><img src="/images/6.23/pic8.jpg"></p>
<p><img src="/images/6.23/pic9.jpg"></p>
</div><div class="post-meta"><a href="/2022/06/24/Meadow-Picnic-6-23/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Gallery/" rel="tag">Gallery</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/17/LeetCode-Daily-Question-30/" class="post-link">LeetCode Daily Question 30</a></h2><div class="post-info">May 17th 2022</div><div class="post-entry"><h2 id="5-月-14-日-每日一题"><a href="#5-月-14-日-每日一题" class="headerlink" title="5 月 14 日 每日一题"></a>5 月 14 日 每日一题</h2><hr>
<h3 id="105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal"><a href="#105-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal" class="headerlink" title="105. Construct Binary Tree from Preorder and Inorder Traversal"></a>105. Construct Binary Tree from Preorder and Inorder Traversal</h3><p>One way to serialize a binary tree is to use preorder traversal. When we encounter a non-null node, we record the node’s value. If it is a null node, we record using a sentinel value such as ‘#’.</p>
<p>For example, the above binary tree can be serialized to the string “9,3,4,#,#,1,#,#,2,#,6,#,#”, where ‘#’ represents a null node.</p>
<p>Given a string of comma-separated values preorder, return true if it is a correct preorder traversal serialization of a binary tree.</p>
<p>It is guaranteed that each comma-separated value in the string must be either an integer or a character ‘#’ representing null pointer.</p>
<p>You may assume that the input format is always valid.</p>
<p>For example, it could never contain two consecutive commas, such as “1,,3”.<br>Note: You are not allowed to reconstruct the tree.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: preorder = &quot;9,3,4,#,#,1,#,#,2,#,6,#,#&quot;</span><br><span class="line">Output: true</span><br><span class="line">Example 2:</span><br><span class="line"></span><br><span class="line">Input: preorder = &quot;1,#&quot;</span><br><span class="line">Output: false</span><br><span class="line">Example 3:</span><br><span class="line"></span><br><span class="line">Input: preorder = &quot;9,#,#,1&quot;</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题有两种写法，我用了最笨的一种，每遇到两个#，将这两个 hash 和对应的 leaf node 删掉，然后添加一个#，要注意的是需要使用 while 循环，因为可能会在添加#之后形成新的满足 pop 要求的组合。要注意的是不能直接用 index 访问，因为可能会出现两位数字（92）。<br>另一种写法是聪明很多，因为 external node 数量必然比 internal 多 1，每遇到一个 val，counter++，遇到#，counter–，如果读完所有的 node 时，count 为-1，则有效（如果未读完所有 node，count 就为 1，意味着此时已经无法插入 node，则此 tree 无效）。<br><img src="/2022/05/17/LeetCode-Daily-Question-30/%E6%88%AA%E5%B1%8F2022-05-18%20%E4%B8%8B%E5%8D%888.44.49_31e0yfghz.png" alt="截屏2022-05-18 下午8.44.49"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValidSerialization</span><span class="params">(string preorder)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//if it&#x27;s #</span></span><br><span class="line">        <span class="keyword">if</span>(preorder[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; preorder.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>  <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(preorder[<span class="number">0</span>] == <span class="string">&#x27;#&#x27;</span> &amp;&amp; preorder.<span class="built_in">size</span>() != <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        preorder += <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        <span class="function">stringstream <span class="title">str</span><span class="params">(preorder)</span></span>;</span><br><span class="line">        string ele;</span><br><span class="line">        <span class="built_in">getline</span>(str, ele, <span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">        vector&lt;string&gt; stack;</span><br><span class="line">        stack.<span class="built_in">push_back</span>(ele);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(str, ele, <span class="string">&#x27;,&#x27;</span>))&#123;</span><br><span class="line">            stack.<span class="built_in">push_back</span>(ele);</span><br><span class="line">            <span class="keyword">if</span>(stack.<span class="built_in">back</span>() == <span class="string">&quot;#&quot;</span>)&#123;</span><br><span class="line">                <span class="keyword">while</span>(stack.<span class="built_in">size</span>() &gt; <span class="number">2</span> &amp;&amp; stack.<span class="built_in">back</span>() == <span class="string">&quot;#&quot;</span> &amp;&amp; stack[stack.<span class="built_in">size</span>() - <span class="number">2</span>] == <span class="string">&quot;#&quot;</span> &amp;&amp; stack[stack.<span class="built_in">size</span>() - <span class="number">3</span>] != <span class="string">&quot;#&quot;</span> )&#123;</span><br><span class="line">                    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">                    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">                    stack.<span class="built_in">pop_back</span>();</span><br><span class="line">                    stack.<span class="built_in">push_back</span>(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.<span class="built_in">size</span>() == <span class="number">1</span> &amp;&amp; stack.<span class="built_in">back</span>() == <span class="string">&quot;#&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidSerialization</span><span class="params">(string p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stringstream ss&#123;p&#125;;</span><br><span class="line">	<span class="type">int</span> c&#123;<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">for</span>( ; c!=<span class="number">-1</span> <span class="keyword">and</span> !ss.<span class="built_in">eof</span>(); <span class="built_in">getline</span>(ss, p, <span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">        p[<span class="number">0</span>]==<span class="string">&#x27;#&#x27;</span> ? --c : ++c；</span><br><span class="line">	<span class="keyword">return</span> c==<span class="number">-1</span> <span class="keyword">and</span> ss.<span class="built_in">eof</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/17/LeetCode-Daily-Question-30/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/tree/" rel="tag">tree</a></div></div></article></div><div class="paginator"><div class="next-wrap col-md-6 col-xs-6 col-md-offset-6 col-xs-offset-6"><a href="/page/2/" class="next-page">Next</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;秋&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>