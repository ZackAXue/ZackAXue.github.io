<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>MyBlog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">秋</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li><li class="menu-item"><a href="/about/" target="_self">ABOUT</a></li></ul></div></nav><main class="prince-container"><div class="articles"><article class="post-block"><h2 class="post-title"><a href="/2022/05/11/LeetCode-Daily-Question-28/" class="post-link">LeetCode Daily Question 28</a></h2><div class="post-info">May 11th 2022</div><div class="post-entry"><h2 id="5-月-11-日-每日一题"><a href="#5-月-11-日-每日一题" class="headerlink" title="5 月 11 日 每日一题"></a>5 月 11 日 每日一题</h2><hr>
<h3 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101. Symmetric Tree"></a>101. Symmetric Tree</h3><p>Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,2,3,4,4,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>Recursive 写法：<br>首先思考问题与子问题的递归关系，可分为三种 case，第一种是只有一个 node，必然 true；第二种是三个 node，需要满足 left-&gt;val &#x3D;&#x3D; right-&gt;val；第三种是 height 大于 3 的 completed tree，需要满足 left-&gt;val &#x3D;&#x3D; right-&gt;val 并且 left-&gt;left tree 与 right-&gt;right tree 相同，left-&gt;right 与 right-&gt;left 相同。<br>之后思考 base case，left&#x2F;right 有一个空或全空。<br>最后将以上归纳为函数代码(首先将 root-&gt;left，right）传入函数可以自然判断前两种 case。</p>
<p>Iterative 写法：<br>逻辑类似 BSF，首先将 root-&gt;left,right 放入 queue，while 判断条件为 queue 非空，在 while 内判断 val 并且按递归 case3 的顺序 push 进 queue.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SymmetricHelper</span>(root-&gt;left, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">SymmetricHelper</span><span class="params">(TreeNode *left, TreeNode *right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!left || !right)</span><br><span class="line">            <span class="keyword">return</span> left == right;</span><br><span class="line">        <span class="keyword">if</span>(left-&gt;val != right-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">SymmetricHelper</span>(left-&gt;left, right-&gt;right) &amp;&amp; <span class="built_in">SymmetricHelper</span>(left-&gt;right, right-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        queue&lt;TreeNode*&gt; queue;</span><br><span class="line">        queue.<span class="built_in">push</span>(root-&gt;left);</span><br><span class="line">        queue.<span class="built_in">push</span>(root-&gt;right);</span><br><span class="line">        <span class="keyword">while</span>(!queue.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode *left = queue.<span class="built_in">front</span>(); queue.<span class="built_in">pop</span>();</span><br><span class="line">            TreeNode *right = queue.<span class="built_in">front</span>(); queue.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!left || !right) <span class="keyword">return</span> left == right;</span><br><span class="line">            <span class="keyword">if</span>(left-&gt;val != right-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            queue.<span class="built_in">push</span>(left-&gt;left);</span><br><span class="line">            queue.<span class="built_in">push</span>(right-&gt;right);</span><br><span class="line">            queue.<span class="built_in">push</span>(left-&gt;right);</span><br><span class="line">            queue.<span class="built_in">push</span>(right-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/11/LeetCode-Daily-Question-28/" class="article-more">Read More</a></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/10/LeetCode-Daily-Question-27/" class="post-link">LeetCode Daily Question 27</a></h2><div class="post-info">May 10th 2022</div><div class="post-entry"><h2 id="5-月-10-日-每日一题"><a href="#5-月-10-日-每日一题" class="headerlink" title="5 月 10 日 每日一题"></a>5 月 10 日 每日一题</h2><hr>
<h3 id="题目：99-Recover-Binary-Search-Tree"><a href="#题目：99-Recover-Binary-Search-Tree" class="headerlink" title="题目：99. Recover Binary Search Tree"></a>题目：99. Recover Binary Search Tree</h3><p>You are given the root of a binary search tree (BST), where the values of exactly two nodes of the tree were swapped by mistake. Recover the tree without changing its structure.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [3,1,4,null,null,2]</span><br><span class="line">Output: [2,1,4,null,null,3]</span><br><span class="line">Explanation: 2 cannot be in the right subtree of 3 because 2 &lt; 3. Swapping 2 and 3 makes the BST valid.</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题核心是利用 inorder traversal 检测错误点（BSF 的 inorder 应该为从小到大），如果检测到两组顺序不同的 node，则为第一组 node 的第一个位置和第二组 node 的第二个位置。因此需要两个 pointer first 和 second 记录这两个位置。需要注意的是 prev 的初始值应该为 infinitMin。<br>注意 prev 初始为 infmin</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *firstRemove, *secondRemove, *prev;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        prev = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(INT_MIN);</span><br><span class="line">        <span class="built_in">inorderHelper</span>(root);</span><br><span class="line">        <span class="built_in">swap</span>(firstRemove-&gt;val, secondRemove-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inorderHelper</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">inorderHelper</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(firstRemove == <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; prev-&gt;val)</span><br><span class="line">            firstRemove = prev;</span><br><span class="line">        <span class="keyword">if</span>(firstRemove != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; prev-&gt;val)</span><br><span class="line">            secondRemove = root;</span><br><span class="line">        prev = root;</span><br><span class="line">        <span class="built_in">inorderHelper</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/10/LeetCode-Daily-Question-27/" class="article-more">Read More</a></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/09/LeetCode-Daily-Question-26/" class="post-link">LeetCode Daily Question 26</a></h2><div class="post-info">May 9th 2022</div><div class="post-entry"><h2 id="5-月-9-日-每日一题"><a href="#5-月-9-日-每日一题" class="headerlink" title="5 月 9 日 每日一题"></a>5 月 9 日 每日一题</h2><hr>
<h3 id="题目：237-Delete-Node-in-a-Linked-List"><a href="#题目：237-Delete-Node-in-a-Linked-List" class="headerlink" title="题目：237. Delete Node in a Linked List"></a>题目：237. Delete Node in a Linked List</h3><p>Write a function to delete a node in a singly-linked list. You will not be given access to the head of the list, instead you will be given access to the node to be deleted directly.</p>
<p>It is guaranteed that the node to be deleted is not a tail node in the list.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一道 easy 题，先将下一个 node 的信息保存到该 node，然后删除下一 node。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">struct</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     ListNode *next;</span><br><span class="line">     <span class="built_in">ListNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">deleteNode</span><span class="params">(ListNode* node)</span> </span>&#123;</span><br><span class="line">        node-&gt;val = node-&gt;next-&gt;val;</span><br><span class="line">        ListNode* forwarding = node-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> node-&gt;next;</span><br><span class="line">        node-&gt;next = forwarding;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/09/LeetCode-Daily-Question-26/" class="article-more">Read More</a></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/08/LeetCode-Daily-Question-25/" class="post-link">LeetCode Daily Question 25</a></h2><div class="post-info">May 8th 2022</div><div class="post-entry"><h2 id="5-月-8-日-每日一题"><a href="#5-月-8-日-每日一题" class="headerlink" title="5 月 8 日 每日一题"></a>5 月 8 日 每日一题</h2><hr>
<h3 id="题目：141-Linked-List-Cycle"><a href="#题目：141-Linked-List-Cycle" class="headerlink" title="题目：141. Linked List Cycle"></a>题目：141. Linked List Cycle</h3><p>Given head, the head of a linked list, determine if the linked list has a cycle in it.</p>
<p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail’s next pointer is connected to. Note that pos is not passed as a parameter.</p>
<p>Return true if there is a cycle in the linked list. Otherwise, return false.</p>
<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>两种思路，快慢指针和 hashmap&#x2F;set，hashmap 需要注意 value 可能重复所以 key 应该使用 ListNode*类型。快慢指针需要考虑 head 为 nullptr，linkList 只有两个的 edge case（建议提前列出 0 1 2 3 个 Node 的情况。</p>
<p>需要注意的是，unorder_map 的 count 函数，如果该 key 存在，返回 1，不存在返回 0。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *slow = head;</span><br><span class="line">        ListNode *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next )&#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/08/LeetCode-Daily-Question-25/" class="article-more">Read More</a></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/07/LeetCode-Daily-Question-24/" class="post-link">LeetCode Daily Question 24</a></h2><div class="post-info">May 7th 2022</div><div class="post-entry"><h2 id="5-月-7-日-每日一题"><a href="#5-月-7-日-每日一题" class="headerlink" title="5 月 7 日 每日一题"></a>5 月 7 日 每日一题</h2><hr>
<h3 id="题目：284-Peeking-Iterator"><a href="#题目：284-Peeking-Iterator" class="headerlink" title="题目：284. Peeking Iterator"></a>题目：284. Peeking Iterator</h3><p>Given the head of a singly linked list and two integers left and right where left &lt;&#x3D; right, reverse the nodes of the list from position left to position right, and return the reversed list.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: head = [1,2,3,4,5], left = 2, right = 4</span><br><span class="line">Output: [1,4,3,2,5]</span><br><span class="line">Example 2:</span><br><span class="line">Input: head = [5], left = 1, right = 1</span><br><span class="line">Output: [5]</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>I. Dummy Node<br>用于避免 reverse 的 left 为 head 的 edge case，结束时返回 dummy node 的 next 即可。</p>
<p>II. 移动指针，将指针指向 left，并且需要记录 left 的前一个 node，以便结束时 connect。需要注意的是循环的运行次数应该为 left - 1.</p>
<p>III. 对要求区域进行 reverse，需要记录 curr，prev 和 forwarding，流程为，首先记录 current node 的 next，然后将 current node 的 next 指向 prev，然后将 prev 更新为 current node，current node 更新为 forwarding node。reverse 的次数为 right - left + 1，这是因为第一次循环 prev 为 nullptr。</p>
<p>IV. 连接 reverse 区域与其余区域，此时 current 指向 node after right，并且 leftPrev 的 next 为 reverse 前的 left。首先将 reverse 前的 left 的 next 指向 current。然后将 leftPrev 的 next 指向 prev（right）。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//dummy node</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummy-&gt;next = head;</span><br><span class="line">        <span class="comment">//go to left</span></span><br><span class="line">        ListNode *leftPrev = dummy;</span><br><span class="line">        ListNode *cur = dummy-&gt;next;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++)&#123;</span><br><span class="line">            leftPrev = cur;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;<span class="comment">//now cur points to left</span></span><br><span class="line">        <span class="comment">//reverse from left to right</span></span><br><span class="line">        ListNode* prev = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = left; i &lt; right + <span class="number">1</span>; i++)&#123;</span><br><span class="line">            ListNode* forwarding = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = prev;</span><br><span class="line">            prev = cur;</span><br><span class="line">            cur = forwarding;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//connect</span></span><br><span class="line">        leftPrev-&gt;next-&gt;next = cur;</span><br><span class="line">        leftPrev-&gt;next = prev;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/07/LeetCode-Daily-Question-24/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/linkList/" rel="tag">linkList</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/06/LeetCode-Daily-Question-23/" class="post-link">LeetCode Daily Question 23</a></h2><div class="post-info">May 6th 2022</div><div class="post-entry"><h2 id="5-月-6-日-每日一题"><a href="#5-月-6-日-每日一题" class="headerlink" title="5 月 6 日 每日一题"></a>5 月 6 日 每日一题</h2><hr>
<h3 id="题目：284-Peeking-Iterator"><a href="#题目：284-Peeking-Iterator" class="headerlink" title="题目：284. Peeking Iterator"></a>题目：284. Peeking Iterator</h3><p>Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations.</p>
<p>Implement the PeekingIterator class:</p>
<p>PeekingIterator(Iterator<int> nums) Initializes the object with the given integer iterator iterator.<br>int next() Returns the next element in the array and moves the pointer to the next element.<br>boolean hasNext() Returns true if there are still elements in the array.<br>int peek() Returns the next element in the array without moving the pointer.<br>Note: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions.</int></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Input</span><br><span class="line">[&quot;PeekingIterator&quot;, &quot;next&quot;, &quot;peek&quot;, &quot;next&quot;, &quot;next&quot;, &quot;hasNext&quot;]</span><br><span class="line">[[[1, 2, 3]], [], [], [], [], []]</span><br><span class="line">Output</span><br><span class="line">[null, 1, 2, 2, 3, false]</span><br><span class="line"></span><br><span class="line">Explanation</span><br><span class="line">PeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]</span><br><span class="line">peekingIterator.next();    // return 1, the pointer moves to the next element [1,2,3].</span><br><span class="line">peekingIterator.peek();    // return 2, the pointer does not move [1,2,3].</span><br><span class="line">peekingIterator.next();    // return 2, the pointer moves to the next element [1,2,3]</span><br><span class="line">peekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]</span><br><span class="line">peekingIterator.hasNext(); // return False</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题没什么好说的，看懂题就能做出来，奈何我没看懂题…</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PeekingIterator</span> : <span class="keyword">public</span> Iterator &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">bool</span> isHasNext;</span><br><span class="line">    <span class="type">int</span> nextVal;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PeekingIterator</span>(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums) : <span class="built_in">Iterator</span>(nums) &#123;</span><br><span class="line">        <span class="comment">// Initialize any member here.</span></span><br><span class="line">        <span class="comment">// **DO NOT** save a copy of nums and manipulate it directly.</span></span><br><span class="line">        <span class="comment">// You should only use the Iterator interface methods.</span></span><br><span class="line">        isHasNext = Iterator::<span class="built_in">hasNext</span>();</span><br><span class="line">        <span class="keyword">if</span>(isHasNext)</span><br><span class="line">            nextVal = Iterator::<span class="built_in">next</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Returns the next element in the iteration without advancing the iterator.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// hasNext() and next() should behave the same as in the Iterator interface.</span></span><br><span class="line">    <span class="comment">// Override them if needed.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> currNext = nextVal;</span><br><span class="line">        isHasNext = Iterator::<span class="built_in">hasNext</span>();</span><br><span class="line">        <span class="keyword">if</span>(isHasNext)</span><br><span class="line">            nextVal = Iterator::<span class="built_in">next</span>();</span><br><span class="line">        <span class="keyword">return</span> currNext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasNext</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isHasNext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/06/LeetCode-Daily-Question-23/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/06/LeetCode-Daily-Question-22/" class="post-link">LeetCode Daily Question 22</a></h2><div class="post-info">May 6th 2022</div><div class="post-entry"><h2 id="5-月-6-日-每日一题"><a href="#5-月-6-日-每日一题" class="headerlink" title="5 月 6 日 每日一题"></a>5 月 6 日 每日一题</h2><hr>
<h3 id="题目：169-Majority-Element"><a href="#题目：169-Majority-Element" class="headerlink" title="题目：169. Majority Element"></a>题目：169. Majority Element</h3><p>Given an array nums of size n, return the majority element.</p>
<p>The majority element is the element that appears more than ⌊n &#x2F; 2⌋ times. You may assume that the majority element always exists in the array.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line"></span><br><span class="line">Input: nums = [3,2,3]</span><br><span class="line">Output: 3</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题使用 Boyer–Moore majority vote algorithm，因为条件是必然存在 majority，本质可以理解为为每一个元素寻找一个不同的元素进行配对，应该存在 n&#x2F;2 个 pair，但 majority 一定出现多于 n&#x2F;2 次，所以最终剩余的无法配对的元素就是 majority。<img src="https://i.imgur.com/kv3Gl4Q.png" alt="截屏2022-05-06 下午11.44.32"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> majority = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;num: nums)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= <span class="number">1</span>)</span><br><span class="line">                count += (num == majority) ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                majority = num;</span><br><span class="line">                count = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> majority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/06/LeetCode-Daily-Question-22/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/06/LeetCode-Daily-Question-21/" class="post-link">LeetCode Daily Question 21</a></h2><div class="post-info">May 6th 2022</div><div class="post-entry"><h2 id="5-月-5-日-每日一题"><a href="#5-月-5-日-每日一题" class="headerlink" title="5 月 5 日 每日一题"></a>5 月 5 日 每日一题</h2><hr>
<h3 id="题目：11-Container-With-Most-Water"><a href="#题目：11-Container-With-Most-Water" class="headerlink" title="题目：11. Container With Most Water"></a>题目：11. Container With Most Water</h3><p>You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).</p>
<p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p>
<p>Return the maximum amount of water a container can store.</p>
<p>Notice that you may not slant the container.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: height = [1,8,6,2,5,4,8,3,7]</span><br><span class="line">Output: 49</span><br><span class="line">Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49.</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>本题是关于双指针和贪心的题目，Greedy 的逻辑为：从可能最大的宽度起始，如果左边小，则 left++，如果右边小则 right–。因为水面高度永远取最小，所以如果移动大的一边，体积必然下降。如果 greedy 后得出的体积比当前的 maxArea 大，则修改当前 maxArea。</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(height.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(left != right)&#123;</span><br><span class="line">            maxArea = <span class="built_in">max</span>(<span class="built_in">min</span>(height[left], height[right]) * (right - left), maxArea);</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right])</span><br><span class="line">                left++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-meta"><a href="/2022/05/06/LeetCode-Daily-Question-21/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Greedy/" rel="tag">Greedy</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/05/02/%E5%86%99%E5%9C%A822WN%E7%9A%84%E6%9C%80%E5%90%8E/" class="post-link">写在22WN结束之后</a></h2><div class="post-info">May 2nd 2022</div><div class="post-entry"><p><img src="https://i.imgur.com/v7lcEWF.jpg" alt="16521651549140_.pic_hd"></p>
<h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>今天收到了 370 的 letter grade，有惊无险，算是圆满结束我的 22Winter Term。本篇文章旨在分析本学期几门课的学习效果。</p>
<h3 id="EECS-281"><a href="#EECS-281" class="headerlink" title="EECS 281"></a>EECS 281</h3><p>本学期最重量级的一门专业课，workload 60%出头，在完成四个 project 之外，还需要每周完成 lab 的 quiz，coding assignment，和 written problem。这门课最奇怪的还是抽题制考试，每个人考题难度差距很离谱，例如我觉得极难的 midterm 选择题平均分 45 分，但我觉得相对简单很多的 final 选择题平均分却是 35 分。感谢这门课的 Final，把我抬上了 A+。</p>
<p>学习这门课只是停留在 lecture 是肯定不够的，搭配 IA 的 Leetcode List 可以帮助掌握知识点，有时间的话强烈建议读一遍 notes，notes 的内容要比 slides 更细节，也涉及了更多知识点。</p>
<h3 id="EECS-370"><a href="#EECS-370" class="headerlink" title="EECS 370"></a>EECS 370</h3><p>本学期第二重量级的专业课，computer organization。内容偏重概念，project 是实现 Lc2k 的 assembler， simulator， linker 等一系列东西，以及写几个汇编软件。考试细心非常重要，我两次考得都一般，但 project 和 hw 拉满，所以拿 A 飘过了。</p>
<h3 id="STATS-250"><a href="#STATS-250" class="headerlink" title="STATS 250"></a>STATS 250</h3><p>巨水的统计课，讲了几个分布，如何做 Hypothesis Test &amp; Confidence Interval， 学了一些基础的 R， A+结束。</p>
<h3 id="EARTH-114，-LING-137，-ELI-210-and-ELI-131"><a href="#EARTH-114，-LING-137，-ELI-210-and-ELI-131" class="headerlink" title="EARTH 114， LING 137， ELI 210 and ELI 131"></a>EARTH 114， LING 137， ELI 210 and ELI 131</h3><p>前三门没有什么可说的，三门大水课，拿 A 了事。后两门 ELI 因为太忙，没有花多少时间，所以效果很差。</p>
<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><p>对于像我一样第一次学数据结构的学生，不建议在一个学期同时学 370 和 281，我个人感觉 281 没有学扎实，计划暑假继续刷题，夯实基础。</p>
<p>虽然没有上过 STATS 412，考虑到 412 不用做无聊的 lab，我觉得会是比 250 更好的选择。</p>
</div><div class="post-meta"><a href="/2022/05/02/%E5%86%99%E5%9C%A822WN%E7%9A%84%E6%9C%80%E5%90%8E/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Summary/" rel="tag">Summary</a></div></div></article><article class="post-block"><h2 class="post-title"><a href="/2022/04/13/%E5%86%99%E5%9C%A822WN%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAproject%E5%AE%8C%E7%BB%93%E4%B9%8B%E5%90%8E/" class="post-link">写在22WN最后一个project完结之后</a></h2><div class="post-info">Apr 13th 2022</div><div class="post-entry"><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本周终于做完了 370，281 两门课的 Project4，虽然并没有如释重负的感觉（因为后面就是 Final），但还是有点小开心。这篇博文就总结一下这次的两个 p4。</p>
<h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><p>模拟一个简单的 Cache 运行，并且和 p1 写的 simulator 链接。需要考虑两种大情况，hit 和 miss，并且在 miss 时分类讨论是否有 empty block，难点应该是地址的转换。</p>
<h4 id="Debug-教训"><a href="#Debug-教训" class="headerlink" title="Debug 教训"></a>Debug 教训</h4><p>我写了一个比较离谱的 bug，if else 中都有 return，然后在 if else 结束之后写了一段对 LRU 的操作，如图：<br><img src="/images/370bug.png"><br>导致对 LRU 的操作没有执行。</p>
<h3 id="Pokemon"><a href="#Pokemon" class="headerlink" title="Pokemon"></a>Pokemon</h3><p>大概设定是你是一名宝可梦训练家，要收集齐所有宝可梦。从一些设定上看得出这个 Project 的作者应该是个资深的宝可梦的玩家，比如，二周目可以使用飞行（随意连接地图上的两个点），一周目如果要下海，必须先捕捉一只岸边的宝可梦获得冲浪技能。</p>
<p>PartA 本质上是写一个有限制的 MST，在搜寻目标点周围相邻点标记距离时增加一个 coast 和 sea 的判断（至少有一方在 coast 或两点都在 land），如果不符合则不标记两点之间的 d。MST 的本质是逐步选择和 SubGraph 最近的点并且逐步扩大 SubGraph，直到访问所有点。</p>
<p>PartB&amp;C 关于 TSP（traveling salesperson problem），即找到一条最优的路径访问所有点后并回到起始点构成一个环（Hamiltonian cycle）。</p>
<p>PartB 需要完成一个 FastTSP（TSP Heuristics） ，即更快的找到一条相对接近 Optimal TSP 的路径。我使用了 Arbitrary Insertion 的方法。</p>
<ol>
<li>随机选择第一个点 i</li>
<li>找到离 i 最近的第二个点 j，将路径设为 i -&gt; j -&gt; i。</li>
<li>对所有剩余的点进行循环，每次循环找到一个点加入当前的环（cost 最小），即遍历所有的 j 和 j-1 计算 (j -&gt; candidate -&gt; j-1) - (j -&gt; j-1) cost 最小时即为最优点。<br>*具体可见 281NotesC22Page37</li>
</ol>
<p>PartC 需要找到最优的 TSP，并尽可能优化算法，代码核心为 GenPerm（遍历所有可能的排列），为了尽可能增加效率，需要应用 Branch and Bound 的算法。那此时我们就需要考虑，如何得到算法需要的 upperBound 和 lowerBound？显然，upperBound 就是 PartB 的结果，lowerBound 的估计方法则是先找到两条 arm 一条从剩余点连接到 current path 的起始点，一条从剩余点连接到 current 的结尾点，并对剩余点计算 MST（minimum）。将 arm，current cost， MST 相加，结果极为 Lower Bound（在本问题可以视为最低 cost）。如下图所示：<br><img src="/images/281TSP.jpg"></p>
<h4 id="Debug-教训-1"><a href="#Debug-教训-1" class="headerlink" title="Debug 教训"></a>Debug 教训</h4><p><img src="/images/281bug.jpg"><br>我起初并没有用 tempDis 保存 distance，而是直接在 +&#x3D; 时调用 distancs[][]，但此时因为 swap，OPTpath[i]中的数据已经改变，+-的数据错误。</p>
</div><div class="post-meta"><a href="/2022/04/13/%E5%86%99%E5%9C%A822WN%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AAproject%E5%AE%8C%E7%BB%93%E4%B9%8B%E5%90%8E/" class="article-more">Read More</a><div class="post-tags-box"><a class="tag-link" href="/tags/Summary/" rel="tag">Summary</a></div></div></article></div><div class="paginator"><div class="next-wrap col-md-6 col-xs-6 col-md-offset-6 col-xs-offset-6"><a href="/page/2/" class="next-page">Next</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;秋&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>