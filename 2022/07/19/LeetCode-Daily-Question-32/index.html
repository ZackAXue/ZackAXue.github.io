<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><title>MyBlog</title><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link href="/css/bootstrap.min.css" rel="stylesheet"><link href="/css/font-awesome.min.css" rel="stylesheet"><link href="/css/main.css" rel="stylesheet"><meta name="generator" content="Hexo 6.0.0"></head><body><div class="wrap"><nav class="page-navigation"><div class="nav-container"><div class="page-header-logo"><h1 class="prince-log"><a href="/" class="home-link">秋</a></h1></div><button type="button" data-toggle="collapse" data-target=".main-nav-items" class="navbar-toggle"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><ul class="collapse navbar-collapse main-nav-items"><li class="menu-item"><a href="/" target="_self">HOME</a></li><li class="menu-item"><a href="/archives/" target="_self">ARCHIVE</a></li><li class="menu-item"><a href="/about/" target="_self">ABOUT</a></li></ul></div></nav><main class="prince-container"><div class="post"><article class="post-block"><h1 class="post-title">LeetCode Daily-Question 32</h1><div class="post-info">Jul 19th 2022</div><div class="post-entry"><h2 id="7-月-19-日-每日一题"><a href="#7-月-19-日-每日一题" class="headerlink" title="7 月 19 日 每日一题"></a>7 月 19 日 每日一题</h2><hr>
<h3 id="117-Populating-Next-Right-Pointers-in-Each-Node-II"><a href="#117-Populating-Next-Right-Pointers-in-Each-Node-II" class="headerlink" title="117. Populating Next Right Pointers in Each Node II"></a>117. Populating Next Right Pointers in Each Node II</h3><p>Given a binary tree</p>
<p>struct Node {<br>int val;<br>Node *left;<br>Node *right;<br>Node *next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p>
<p>Initially, all next pointers are set to NULL.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input: root = [1,2,3,4,5,null,7]</span><br><span class="line">Output: [1,#,2,3,#,4,5,7,#]</span><br><span class="line">Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with &#x27;#&#x27; signifying the end of each level.</span><br></pre></td></tr></table></figure>

<h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>The difference between 116 and 117 is that 117 is not a perfect binary tree, which means it cannot be simply solved by recursive.</p>
<p>The direct way is to use iterative BSF. Note that when reach to null, it’s time to move to the next level and add a nullptr to the end of the queue(for the next level end).</p>
<p>There is a O(1) space complexity way, which is a bit similar to double pointer. The detail is in comments of code. Note the when proceed the current level(currParent), the next has been proceed by last while loop.</p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>Way 1:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node* left;</span></span><br><span class="line"><span class="comment">    Node* right;</span></span><br><span class="line"><span class="comment">    Node* next;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() : val(0), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, Node* _left, Node* _right, Node* _next)</span></span><br><span class="line"><span class="comment">        : val(_val), left(_left), right(_right), next(_next) &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        queue&lt;Node*&gt;q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">while</span>(q.<span class="built_in">size</span>() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            Node* curr = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!curr)&#123;</span><br><span class="line">                q.<span class="built_in">push</span>(<span class="literal">nullptr</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curr-&gt;next = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;left)</span><br><span class="line">                q.<span class="built_in">push</span>(curr-&gt;left);</span><br><span class="line">            <span class="keyword">if</span>(curr-&gt;right)</span><br><span class="line">                q.<span class="built_in">push</span>(curr-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Way 2:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        Node *currParent = root;</span><br><span class="line">        Node *baseChild;</span><br><span class="line">        Node *currChild;</span><br><span class="line">        Node *nextChild;</span><br><span class="line">        <span class="keyword">while</span>(currParent)&#123;</span><br><span class="line">            <span class="comment">//reach to a parent with at least one child</span></span><br><span class="line">            <span class="keyword">while</span>(currParent-&gt;next &amp;&amp; !currParent-&gt;left &amp;&amp; !currParent-&gt;right)</span><br><span class="line">                currParent = currParent-&gt;next;</span><br><span class="line">            <span class="comment">//set baseChild and currChild to the first child of the next level</span></span><br><span class="line">            currChild = baseChild = currParent-&gt;left ? currParent-&gt;left : currParent-&gt;right;</span><br><span class="line">            <span class="keyword">while</span>(currChild)&#123;</span><br><span class="line">                <span class="comment">//if currChild is left child and have right sibling</span></span><br><span class="line">                <span class="keyword">if</span>(currParent-&gt;right &amp;&amp; currParent-&gt;right != currChild)&#123;</span><br><span class="line">                    nextChild = currParent-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//move to the adjacent parent</span></span><br><span class="line">                    currParent = currParent-&gt;next;</span><br><span class="line">                    <span class="keyword">while</span>(currParent &amp;&amp; !currParent-&gt;left &amp;&amp; !currParent-&gt;right)&#123;</span><br><span class="line">                        currParent = currParent-&gt;next;</span><br><span class="line">                        <span class="comment">//now currParent has pointed to the next Parent</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//if not reach to the end</span></span><br><span class="line">                    <span class="keyword">if</span>(currParent)&#123;</span><br><span class="line">                        nextChild = currParent-&gt;left ? currParent-&gt;left : currParent-&gt;right;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//if reach to the end</span></span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="comment">//if reach to the end of this level</span></span><br><span class="line">                        nextChild = <span class="literal">nullptr</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                currChild-&gt;next = nextChild;</span><br><span class="line">                currChild = nextChild;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//move to the next level</span></span><br><span class="line">            currParent = baseChild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div><div class="post-tags-box"><a class="tag-link" href="/tags/bfs/" rel="tag">bfs</a>, <a class="tag-link" href="/tags/dailyQuestion/" rel="tag">dailyQuestion</a>, <a class="tag-link" href="/tags/tree/" rel="tag">tree</a></div></article></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E6%9C%88-19-%E6%97%A5-%E6%AF%8F%E6%97%A5%E4%B8%80%E9%A2%98"><span class="toc-text">7 月 19 日 每日一题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#117-Populating-Next-Right-Pointers-in-Each-Node-II"><span class="toc-text">117. Populating Next Right Pointers in Each Node II</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%9D%E8%B7%AF"><span class="toc-text">思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81"><span class="toc-text">代码</span></a></li></ol></li></ol><div class="post-nav"><div class="prev-wrap col-md-6 col-xs-6"><i class="fa fa-angle-double-left"></i><a href="/2022/07/20/LeetCode-Daily-Question-33/" class="prev-post">LeetCode-Daily-Question-33</a></div><div class="next-wrap col-md-6 col-xs-6"><a href="/2022/07/18/LeetCode-Daily-Question-31/" class="next-post">LeetCode Daily Question 31</a><i class="fa fa-angle-double-right"></i></div></div></main></div><footer><div class="copyright"><p>Crafted with <i class="fa fa-heart"></i> by&nbsp;秋&nbsp;|&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yiliashaw/hexo-theme-prince" target="_blank">Prince</a> by SHAW</p></div></footer><script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script><script src="/js/bootstrap.min.js"></script><script src="//cdnjs.cloudflare.com/ajax/libs/fancybox/3.0.47/jquery.fancybox.min.js"></script><script src="/js/script.js"></script></body></html>